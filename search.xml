<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>스프링부트</title>
      <link href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"/>
      <url>/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="스프링부트를-쓰는-이유"><a href="#스프링부트를-쓰는-이유" class="headerlink" title="스프링부트를 쓰는 이유"></a>스프링부트를 쓰는 이유</h2><p>스프링부트는 스프링 프레임워크를 기반으로 한 자바 웹 어플리케이션을 보다 쉽게 개발하고 운영하기 위해 만들어졌습니다. 다음과 같은 이유로 스프링부트를 쓰는 것이 유용합니다.</p><h4 id="1-빠른-개발"><a href="#1-빠른-개발" class="headerlink" title="1. 빠른 개발"></a>1. 빠른 개발</h4><p>스프링부트는 설정이 간단하고, 빠른 애플리케이션 개발을 지원합니다. 개발자가 직접 설정을 할 필요 없이, 스프링부트의 자동설정을 이용하여 필요한 의존성을 추가하고 설정을 적용할 수 있습니다.</p><h4 id="2-간편한-배포"><a href="#2-간편한-배포" class="headerlink" title="2. 간편한 배포"></a>2. 간편한 배포</h4><p>스프링부트는 내장된 서버(Tomcat, Jetty 등)를 이용하여 애플리케이션을 실행할 수 있습니다. 이는 개발자가 별도의 외부 서버를 구축하지 않아도 되며, 배포가 간단해집니다.</p><h4 id="3-통합된-모니터링"><a href="#3-통합된-모니터링" class="headerlink" title="3. 통합된 모니터링"></a>3. 통합된 모니터링</h4><p>스프링부트는 애플리케이션의 상태를 모니터링할 수 있는 엔드포인트(Actuator)를 제공합니다. 이 엔드포인트를 이용하여 메모리 사용량, 쓰레드 개수, JDBC 연결 정보 등을 확인할 수 있습니다.</p><h4 id="4-간단한-테스트-환경-구축"><a href="#4-간단한-테스트-환경-구축" class="headerlink" title="4. 간단한 테스트 환경 구축"></a>4. 간단한 테스트 환경 구축</h4><p>스프링부트는 내장된 서버와 자동설정 기능을 이용하여 간단한 테스트 환경을 구축할 수 있습니다. 개발자는 별도의 서버나 DB 설정 없이 애플리케이션을 바로 테스트할 수 있습니다.</p><h4 id="5-다양한-환경-지원"><a href="#5-다양한-환경-지원" class="headerlink" title="5. 다양한 환경 지원"></a>5. 다양한 환경 지원</h4><p>스프링부트는 다양한 환경에서 애플리케이션을 실행할 수 있습니다. 클라우드 서비스(AWS, GCP 등)를 비롯하여, 스프링클라우드와 통합하여 클라우드에서 애플리케이션을 실행할 수 있습니다.</p><h4 id="6-자동설정-기능"><a href="#6-자동설정-기능" class="headerlink" title="6. 자동설정 기능"></a>6. 자동설정 기능</h4><p>스프링부트는 자동설정 기능을 제공하여 설정을 간단하게 처리할 수 있습니다. 예를 들어, JPA를 이용하여 DB 작업을 수행할 경우, 스프링부트는 자동으로 EntityManager를 생성하고, 트랜잭션 처리를 해줍니다.</p><h4 id="7-개발-환경-구축의-용이성"><a href="#7-개발-환경-구축의-용이성" class="headerlink" title="7. 개발 환경 구축의 용이성"></a>7. 개발 환경 구축의 용이성</h4><p>스프링부트는 개발환경을 구축하는데 있어 많은 도움을 줍니다. Maven, Gradle 등의 빌드 툴을 이용하여 의존성을 관리하고, JAR, WAR 파일을 쉽게 빌드할 수 있습니다. 또한 스프링부트는 스프링 이니셜라이저를 제공하여, 초기 설정을 쉽게 생성할 수 있습니다.</p><h4 id="8-관련-커뮤니티"><a href="#8-관련-커뮤니티" class="headerlink" title="8. 관련 커뮤니티"></a>8. 관련 커뮤니티</h4><p>스프링부트는 스프링 프레임워크를 기반으로 하기 때문에, 스프링 프레임워크와 관련된 다양한 커뮤니티를 활용할 수 있습니다. 또한 스프링부트는 다양한 라이브러리와 프레임워크와 연동이 가능합니다.</p><h4 id="9-성능"><a href="#9-성능" class="headerlink" title="9. 성능"></a>9. 성능</h4><p>스프링부트는 내장된 서버를 이용하므로, 서버를 구축하지 않아도 되며, 클라우드에서 애플리케이션을 실행할 수 있어, 성능면에서 우수한 결과를 보입니다. 또한, 스프링부트는 내부적으로 캐싱을 적용하여 성능을 향상시킬 수 있습니다.</p><h4 id="10-다양한-기능"><a href="#10-다양한-기능" class="headerlink" title="10. 다양한 기능"></a>10. 다양한 기능</h4><p>스프링부트는 다양한 기능을 제공합니다. AOP, 캐싱, 보안 등 다양한 모듈을 이용하여 애플리케이션을 구성할 수 있습니다. 또한, 스프링부트는 스프링데이터를 이용하여 다양한 데이터베이스를 지원하며, 스프링 시큐리티를 이용하여 보안기능을 구현할 수 있습니다.</p><p>스프링부트는 스프링 프레임워크를 보다 쉽게 사용할 수 있도록 만들어졌습니다. 스프링부트를 이용하면 애플리케이션을 빠르게 개발하고, 배포할 수 있으며, 모니터링과 테스트를 간편하게 수행할 수 있습니다. 또한, 다양한 커뮤니티와 라이브러리를 활용하여 애플리케이션을 보다 높은 수준으로 구현할 수 있습니다. 따라서, 스프링부트는 자바 개발자에게 권장되는 프레임워크 중 하나입니다.</p><h2 id="스프링부트는-왜-생겨났을까"><a href="#스프링부트는-왜-생겨났을까" class="headerlink" title="스프링부트는 왜 생겨났을까?"></a>스프링부트는 왜 생겨났을까?</h2><p>스프링부트는 스프링 프레임워크를 기반으로 한 자바 웹 어플리케이션을 보다 쉽게 개발하고 운영하기 위해 만들어졌습니다. 이전에는 스프링 프레임워크를 이용한 개발 시 많은 설정과 라이브러리가 필요했고, 이를 일일이 구성하는 것이 어려웠습니다. 이러한 문제를 해결하기 위해 스프링부트는 자동설정과 스타터(dependency management)를 제공하여 개발자가 불필요한 설정 및 의존성 관리에 신경쓰지 않고, 개발에 집중할 수 있도록 도와줍니다.</p><p>스프링부트의 개발 목적은 다음과 같습니다.</p><ol><li>개발자 생산성 향상<ul><li>스프링부트는 자동설정, 스타터, CLI(Command Line Interface) 등을 제공하여 개발자가 빠르게 개발할 수 있도록 돕습니다.</li></ul></li><li>설정 간소화<ul><li>스프링부트는 설정 파일의 크기를 줄이고, 불필요한 설정을 자동으로 제거하여 개발자가 설정 관리를 쉽게 할 수 있도록 돕습니다.</li></ul></li><li>내장 서버 제공<ul><li>스프링부트는 내장된 서버를 제공하여 개발자가 별도의 서버를 구축하지 않아도 애플리케이션을 실행할 수 있습니다.</li></ul></li><li>확장 가능성<ul><li>스프링부트는 스프링 프레임워크와 연동하여 스프링의 다양한 모듈과 기능을 활용할 수 있습니다.</li></ul></li><li>운영 및 배포의 용이성<ul><li>스프링부트는 애플리케이션의 설정과 라이브러리 의존성을 자동으로 관리하여, 배포 시 일관된 환경을 제공합니다. 또한, 애플리케이션의 상태를 모니터링할 수 있는 엔드포인트를 제공하여, 운영 및 모니터링을 용이하게 합니다.</li></ul></li></ol><h2 id="스프링-DI-Dependency-Injection"><a href="#스프링-DI-Dependency-Injection" class="headerlink" title="스프링 DI (Dependency Injection)"></a>스프링 DI (Dependency Injection)</h2><p>DI는 Dependency Injection의 약자로, 객체간의 의존성을 느슨하게 만들기 위한 디자인 패턴 중 하나입니다. 객체가 직접 의존하는 객체를 생성하거나, 컨테이너가 직접 생성하여 의존성을 주입하는 방식으로 작동합니다.</p><p>스프링에서는 DI를 위해 <code>@Autowired</code> 어노테이션을 제공합니다. <code>@Autowired</code> 어노테이션을 사용하여 의존성 주입을 자동화할 수 있습니다. 이를 통해 객체 간의 결합도를 낮추고, 유지보수 및 확장성을 높일 수 있습니다.</p><h3 id="객체-주입-방식의-종류와-특징"><a href="#객체-주입-방식의-종류와-특징" class="headerlink" title="객체 주입 방식의 종류와 특징"></a>객체 주입 방식의 종류와 특징</h3><p>DI (Dependency Injection)는 객체 간의 의존성을 낮추기 위한 디자인 패턴으로, 스프링에서는 다양한 객체 주입 방식을 제공합니다. 여러 객체 주입 방식의 특징과 차이점을 살펴보겠습니다.</p><h4 id="1-생성자-주입-Constructor-Injection"><a href="#1-생성자-주입-Constructor-Injection" class="headerlink" title="1. 생성자 주입(Constructor Injection)"></a>1. 생성자 주입(Constructor Injection)</h4><p>생성자 주입은 객체를 생성할 때, 생성자를 통해 의존성을 주입하는 방식입니다. 생성자 주입 방식은 다음과 같은 특징이 있습니다.</p><ul><li>불변성(Immutability): 생성자를 통해 한 번 주입되면 의존성을 변경할 수 없습니다.</li><li>필수적인 의존성 주입: 모든 의존성이 생성자에 주입되어야 하기 때문에, 필수적인 의존성이 존재할 경우 사용합니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-Setter-주입-Setter-Injection"><a href="#2-Setter-주입-Setter-Injection" class="headerlink" title="2. Setter 주입(Setter Injection)"></a>2. Setter 주입(Setter Injection)</h4><p>Setter 주입은 Setter 메서드를 통해 의존성을 주입하는 방식입니다. Setter 주입 방식은 다음과 같은 특징이 있습니다.</p><ul><li>유연성: Setter 메서드를 통해 의존성을 변경할 수 있습니다.</li><li>선택적인 의존성 주입: Setter 메서드가 존재하면 해당 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-필드-주입-Field-Injection"><a href="#3-필드-주입-Field-Injection" class="headerlink" title="3. 필드 주입(Field Injection)"></a>3. 필드 주입(Field Injection)</h4><p>필드 주입은 필드를 직접 주입하는 방식입니다. 필드 주입 방식은 다음과 같은 특징이 있습니다.</p><ul><li>코드 가독성 저하: 필드를 직접 주입하면, 해당 필드가 어떤 의존성을 가지는지 명확하지 않습니다.</li><li>유연성: 필드를 직접 주입하면, 의존성을 변경하기 쉽습니다.</li><li>적극적인 의존성 주입: 모든 필드에 대해 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-메서드-주입-Method-Injection"><a href="#4-메서드-주입-Method-Injection" class="headerlink" title="4. 메서드 주입(Method Injection)"></a>4. 메서드 주입(Method Injection)</h4><p>메서드 주입은 일반적인 메서드를 통해 의존성을 주입하는 방식입니다. 메서드 주입 방식은 다음과 같은 특징이 있습니다.</p><ul><li>특정 메서드를 통한 의존성 주입: 일반적인 메서드를 통해 의존성을 주입하기 때문에, 특정 메서드에 대해 유연하게 처리할 수 있습니다.</li><li>선택적인 의존성 주입: 의존성이 존재하는 메서드에 대해서만 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Setter 주입과 메서드 주입(Method Injection)은 서로 비슷한 방법으로 의존성을 주입하는 방식이지만, 몇 가지 차이점이 있습니다.</li></ul><p>Setter 주입은 객체 생성 후, Setter 메서드를 통해 의존성을 주입하는 방식입니다. 이 방식은 의존성이 변경될 가능성이 있는 경우, Setter 메서드를 통해 의존성을 변경할 수 있는 장점이 있습니다.</p><p>메서드 주입은 생성자나 Setter 메서드가 아닌, 클래스 내부의 일반적인 메서드를 통해 의존성을 주입하는 방식입니다. 이 방식은 객체 생성 시점에 의존성이 결정되지 않아도 되는 장점이 있으며, Setter 메서드와 달리 메서드 이름에 제약이 없는 유연한 방식입니다.</p><p>즉, Setter 주입과 메서드 주입은 서로 다른 방식의 의존성 주입 방법입니다. Setter 주입은 Setter 메서드를 이용하여 의존성을 주입하고, 메서드 주입은 생성자나 Setter 메서드 이외의 일반적인 메서드를 이용하여 의존성을 주입합니다.</p><h3 id="객체-주입-방식-선택-시-고려해야-할-사항"><a href="#객체-주입-방식-선택-시-고려해야-할-사항" class="headerlink" title="객체 주입 방식 선택 시 고려해야 할 사항"></a>객체 주입 방식 선택 시 고려해야 할 사항</h3><p>객체 주입 방식을 선택할 때 고려해야 할 사항은 다음과 같습니다.</p><ol><li><p>의존성의 필수&#x2F;선택 여부: 생성자 주입 방식은 모든 의존성을 필수적으로 주입해야 하기 때문에, 필수적인 의존성이 존재하는 경우에 사용됩니다. 반면에 Setter 주입 방식은 선택적인 의존성이 존재하는 경우에 사용됩니다.</p></li><li><p>객체의 불변성: 생성자 주입 방식은 의존성이 주입된 이후에는 의존성을 변경할 수 없습니다. 따라서 불변성이 필요한 객체에는 생성자 주입 방식이 적합합니다.</p></li><li><p>유연성: Setter 주입 방식은 Setter 메서드를 통해 의존성을 변경할 수 있기 때문에, 의존성 변경이 빈번하게 발생하는 경우에 적합합니다.</p></li><li><p>코드 가독성: 필드 주입 방식은 필드를 직접 주입하기 때문에, 코드 가독성이 저하될 수 있습니다. 따라서 코드 가독성이 중요한 경우에는 생성자 주입 방식이나 Setter 주입 방식을 사용하는 것이 좋습니다.</p></li><li><p>특정 메서드를 통한 의존성 주입: 메서드 주입 방식은 특정 메서드를 통해 의존성을 주입하기 때문에, 특정 메서드에 대해 유연하게 처리할 수 있습니다.</p></li></ol><h2 id="스프링-IOC-Inversion-of-Control"><a href="#스프링-IOC-Inversion-of-Control" class="headerlink" title="스프링 IOC (Inversion of Control)"></a>스프링 IOC (Inversion of Control)</h2><p>스프링의 핵심 컨테이너인 ApplicationContext는 Inversion of Control(IoC)을 구현한 것입니다. IoC는 객체 지향 프로그래밍에서 발생하는 의존성 관리 문제를 해결하기 위해 등장한 개념으로, 객체 간의 의존성을 자동으로 연결해주는 프로그래밍 방식입니다.</p><p>스프링의 IoC는 객체의 생성, 소멸 등의 라이프사이클을 관리하며, 객체 간의 의존성을 관리하는 데에 중점을 둡니다. IoC는 객체 간의 의존성을 자동으로 연결해주는 역할을 합니다.</p><p>스프링의 IoC는 객체를 생성하는 시점과 의존성을 주입하는 시점을 분리합니다. 이를 통해 객체의 라이프사이클을 유연하게 관리할 수 있습니다. 스프링의 IoC는 객체 간의 의존성을 자동으로 주입해주는데, 이를 의존성 주입(Dependency Injection, DI)이라고 합니다.</p><p>스프링의 IoC는 빈(Bean)이라는 단위로 객체를 관리합니다. 빈은 ApplicationContext에 등록되어 있으며, 다른 빈에서 의존성 주입을 받을 수 있습니다. 빈은 XML 설정 파일이나 어노테이션을 이용하여 등록할 수 있습니다.</p><p>스프링의 IoC는 다양한 방식으로 의존성 주입을 처리합니다. 주요한 의존성 주입 방식으로는 생성자 주입(Constructor Injection), Setter 주입(Setter Injection), 필드 주입(Field Injection) 등이 있습니다. 이들은 각각 객체 생성 시점에 의존성을 주입하는 방식이 다르며, 상황에 따라 선택해서 사용할 수 있습니다.</p><p>스프링의 IoC는 객체의 생성과 소멸, 의존성 주입 등을 자동으로 처리해주므로, 객체 간의 의존성 관리 문제를 해결할 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다.</p><h2 id="스프링-AOP"><a href="#스프링-AOP" class="headerlink" title="스프링 AOP"></a>스프링 AOP</h2><p>AOP(Aspect-Oriented Programming)는 객체 지향 프로그래밍의 한계를 보완하기 위해 등장한 프로그래밍 패러다임입니다. AOP는 애플리케이션의 핵심 로직에서 발생하는 부가적인 작업들을 모듈화하여 코드의 재사용성과 유지보수성을 높여줍니다.</p><p>스프링 AOP는 스프링 프레임워크에서 제공하는 AOP 구현체입니다. 스프링 AOP는 프록시 패턴을 이용하여 메서드 실행 전&#x2F;후 등 특정 시점에 부가적인 로직을 수행할 수 있습니다.</p><p>스프링 AOP의 주요 구성 요소는 다음과 같습니다.</p><ol><li>Pointcut</li></ol><ul><li>Advice가 적용될 메서드를 지정하는 것을 의미합니다.</li></ul><ol start="2"><li>Advice</li></ol><ul><li>메서드 실행 전&#x2F;후 등 특정 시점에서 수행할 로직을 정의합니다.</li></ul><ol start="3"><li>Joinpoint</li></ol><ul><li>Advice가 적용될 수 있는 위치를 의미합니다. 메서드 호출, 예외 발생 등이 Joinpoint에 해당합니다.</li></ul><ol start="4"><li>Aspect</li></ol><ul><li>Pointcut과 Advice의 결합체를 의미합니다.</li></ul><ol start="5"><li>Target</li></ol><ul><li>AOP가 적용되는 대상 객체를 의미합니다.</li></ul><p>스프링 AOP는 다양한 Advice를 지원합니다.</p><ol><li>Before</li></ol><ul><li>메서드 실행 전에 수행할 로직을 정의합니다.</li></ul><ol start="2"><li>After returning</li></ol><ul><li>메서드 실행 후 리턴 값이 존재할 경우 수행할 로직을 정의합니다.</li></ul><ol start="3"><li>After throwing</li></ol><ul><li>메서드 실행 중 예외가 발생한 경우 수행할 로직을 정의합니다.</li></ul><ol start="4"><li>After</li></ol><ul><li>메서드 실행 후 수행할 로직을 정의합니다.</li></ul><ol start="5"><li>Around</li></ol><ul><li>메서드 실행 전&#x2F;후 등 모든 시점에서 수행할 로직을 정의합니다.</li></ul><p>스프링 AOP는 자바의 Proxy 클래스를 이용하여 프록시 객체를 생성합니다. 이를 통해 타깃 객체의 메서드를 호출하기 전&#x2F;후에 부가적인 로직을 수행할 수 있습니다. 또한, AOP를 적용할 때 XML 설정 파일이나 어노테이션을 이용하여 간편하게 설정할 수 있습니다.</p><p>스프링 AOP를 사용하면 애플리케이션의 핵심 로직과 부가적인 로직을 분리하여 구현할 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있으며, 특히 로깅, 트랜잭션, 보안 등과 같은 공통적인 작업을 간편하게 처리할 수 있습니다.</p><h2 id="스프링-ORM-Object-Relational-Mapping"><a href="#스프링-ORM-Object-Relational-Mapping" class="headerlink" title="스프링 ORM (Object-Relational Mapping)"></a>스프링 ORM (Object-Relational Mapping)</h2><p>ORM은 Object-Relational Mapping의 약자로, 객체와 관계형 데이터베이스 간의 매핑을 자동화하는 기술입니다. 스프링에서는 JPA(Java Persistence API)를 이용하여 ORM을 구현합니다.</p><p>스프링에서 ORM을 이용하면 객체지향적인 방식으로 데이터를 다룰 수 있습니다. 또한, ORM을 이용하면 SQL을 직접 작성하는 것보다 더 간편하게 데이터를 다룰 수 있습니다. 스프링에서는 Hibernate, MyBatis 등 다양한 ORM 프레임워크를 지원합니다.</p><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>Hibernate는 자바 언어를 위한 ORM(Object-Relational Mapping) 프레임워크입니다. ORM은 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리하는 기술입니다. 이를 통해 SQL 쿼리를 직접 작성하지 않아도 데이터베이스와 상호작용할 수 있습니다.</p><p>Hibernate는 객체와 데이터베이스 간의 매핑을 위해 XML 또는 어노테이션을 사용할 수 있습니다. Hibernate는 객체를 데이터베이스 테이블에 매핑하는 방식으로 동작합니다. 이를 위해 개발자는 데이터베이스 스키마와 매핑되는 Java 클래스를 작성하고, Hibernate 설정 파일을 작성하여 데이터베이스 연결 정보를 설정합니다.</p><p>Hibernate는 자바 Persistence API(JPA)를 구현하는 ORM 프레임워크입니다. JPA는 Java에서 ORM을 구현하기 위한 표준 인터페이스입니다. Hibernate는 JPA의 구현체 중 하나로, JPA에서 정의한 인터페이스를 구현하여 ORM을 제공합니다.</p><p>Hibernate는 데이터베이스와의 상호작용을 위해 Session과 Transaction 개념을 사용합니다. Session은 데이터베이스와의 세션을 의미하며, 데이터베이스 연결과 동일한 개념입니다. Transaction은 데이터베이스에서 수행되는 일련의 작업을 의미하며, 일반적으로 Session 내에서 실행됩니다.</p><p>Hibernate의 주요 기능으로는 다음과 같은 것들이 있습니다.</p><p>객체와 데이터베이스 간의 매핑 처리<br>객체와 데이터베이스 간의 관계 처리<br>객체와 데이터베이스 간의 쿼리 처리<br>객체와 데이터베이스 간의 트랜잭션 처리<br>Hibernate는 자바에서 ORM을 구현하는 대표적인 프레임워크 중 하나입니다. JPA를 구현한 ORM 프레임워크 중에서도 가장 널리 사용되는 프레임워크 중 하나이며, 대규모 애플리케이션에서도 안정적으로 사용됩니다.</p><h4 id="MyBatis-와-Hibernate"><a href="#MyBatis-와-Hibernate" class="headerlink" title="MyBatis 와 Hibernate"></a>MyBatis 와 Hibernate</h4><p>MyBatis와 Hibernate은 모두 자바에서 사용되는 ORM 프레임워크입니다. 하지만, MyBatis는 Hibernate과는 다른 방식으로 동작합니다.</p><p>MyBatis는 SQL 매핑 기반의 ORM 프레임워크로, 개발자가 직접 SQL 쿼리를 작성하고, 데이터베이스와 상호작용할 수 있는 방식으로 동작합니다. MyBatis는 SQL 매핑 파일과 Java 인터페이스를 이용하여 데이터베이스와의 상호작용을 처리합니다. 이에 비해 Hibernate는 객체와 데이터베이스 간의 매핑을 처리하며, SQL 쿼리를 자동으로 생성합니다.</p><p>MyBatis는 JDBC를 이용하여 데이터베이스와 상호작용하며, SQL 쿼리를 직접 작성할 수 있습니다. 반면, Hibernate는 JDBC보다 더 높은 추상화 수준을 제공하며, 객체와 데이터베이스 간의 매핑을 자동으로 처리합니다.</p><p>따라서, MyBatis는 Hibernate과는 다른 방식으로 동작합니다. MyBatis에서는 Hibernate과 같은 ORM 프레임워크에서 제공하는 객체와 데이터베이스 간의 매핑 기능이 제한적이며, 대신 SQL 쿼리를 직접 작성하여 데이터베이스와 상호작용하는 방식으로 동작합니다.</p><h2 id="스프링-MVC-life-cycle"><a href="#스프링-MVC-life-cycle" class="headerlink" title="스프링 MVC life cycle"></a>스프링 MVC life cycle</h2><p>스프링 MVC의 라이프사이클은 크게 다음과 같은 단계로 구성됩니다.</p><p>요청 처리 과정 시작</p><p>HandlerMapping을 통한 핸들러 검색</p><p>HandlerAdapter를 통한 핸들러 실행</p><p>ViewResolver를 통한 뷰 검색</p><p>ModelAndView를 이용한 뷰 실행</p><p>요청 처리 과정 종료</p><p>요청 처리 과정 시작<br>사용자가 HTTP 요청을 서버에 전송하면, 해당 요청은 DispatcherServlet에 의해 처리됩니다. DispatcherServlet은 스프링 컨테이너에 등록된 모든 빈을 검색하며, HandlerMapping, HandlerAdapter, ViewResolver 등의 빈을 찾아 사용합니다.</p><p>HandlerMapping을 통한 핸들러 검색<br>DispatcherServlet은 HandlerMapping 빈을 찾아 핸들러를 검색합니다. HandlerMapping은 요청 URI를 이용하여 적절한 핸들러를 검색하며, 해당 핸들러가 없을 경우 404 에러를 반환합니다.</p><p>HandlerAdapter를 통한 핸들러 실행<br>HandlerMapping을 통해 검색된 핸들러는 HandlerAdapter를 이용하여 실행됩니다. HandlerAdapter는 검색된 핸들러가 처리할 수 있는 형태로 요청을 변환하고, 핸들러가 처리한 결과를 ModelAndView 객체에 담아 반환합니다.</p><p>ViewResolver를 통한 뷰 검색<br>ModelAndView 객체는 DispatcherServlet에 반환됩니다. DispatcherServlet은 ViewResolver 빈을 이용하여 뷰를 검색합니다. ViewResolver는 검색된 뷰의 위치와 형식을 찾아 반환합니다.</p><p>ModelAndView를 이용한 뷰 실행<br>검색된 뷰는 DispatcherServlet에 의해 실행됩니다. ModelAndView 객체에 담겨있는 데이터를 이용하여 뷰가 생성되며, HTML, JSP, JSON 등의 형식으로 응답됩니다.</p><p>요청 처리 과정 종료<br>뷰가 실행된 후, DispatcherServlet은 요청 처리 과정을 종료합니다. 이때, 요청과 응답 객체는 Servlet Container에 반환됩니다.</p><p>스프링 MVC의 라이프사이클은 요청 처리에 필요한 여러 개의 빈들을 순서에 맞게 실행하며, 요청과 응답 객체를 생성 및 관리합니다. 이를 통해 사용자 요청에 대한 적절한 응답을 반환할 수 있습니다.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>스프링부트 배치</title>
      <link href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98/"/>
      <url>/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98/</url>
      
        <content type="html"><![CDATA[<p>스프링 배치는 대량의 데이터를 처리하는 데 유용한 오픈소스 프레임워크이다. 이를 이용하여 데이터베이스나 파일 시스템과 같은 데이터 저장소에서 데이터를 추출하고 가공한 후, 다시 저장소에 저장하는 등의 작업을 수행할 수 있다. 이를 통해 대량의 데이터를 효율적으로 처리할 수 있으며, 이를 자동화하여 일괄처리를 가능하게 하여 개발자의 업무 효율성을 높일 수 있다.</p><p>스프링 배치의 장점은 다음과 같다.</p><ul><li>대량의 데이터를 처리하는데 최적화되어 있다.</li><li>배치 작업의 이력을 관리하며, 실패한 작업을 다시 수행할 수 있다.</li><li>스케줄링 기능을 지원하여 주기적인 작업을 자동화할 수 있다.</li><li>재사용성이 높은 컴포넌트 기반 아키텍처를 제공한다.</li></ul><p>따라서, 대량의 데이터를 처리하고자 할 때 스프링 배치를 사용하는 것이 유용하며, 스프링 프레임워크를 사용하는 경우에는 쉽게 연동하여 사용할 수 있다.</p><h2 id="사용-선택-기준"><a href="#사용-선택-기준" class="headerlink" title="사용 선택 기준"></a>사용 선택 기준</h2><p>스프링 배치를 사용하는 것이 적절한 경우는 대량의 데이터를 처리해야 할 때입니다. 이를 자동화하여 일괄 처리하고자 하는 경우에도 스프링 배치는 유용합니다. 예를 들어, 은행에서는 매일 수백만 건의 거래 데이터를 처리해야 하므로, 이를 스프링 배치를 이용하여 처리할 수 있습니다.</p><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul><li>대량의 데이터를 처리하는 데 최적화되어 있습니다.</li><li>배치 작업의 이력을 관리할 수 있어, 실패한 작업을 다시 수행할 수 있습니다.</li><li>스케줄링 기능을 제공하여 주기적인 작업을 자동화할 수 있습니다.</li><li>재사용성이 높은 컴포넌트 기반 아키텍처를 제공합니다.</li></ul><h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><ul><li>배치 작업을 위한 코드를 작성하려면 일정한 학습 곡선이 필요합니다.</li><li>배치 작업을 디버깅하고 문제를 해결하는 데 시간이 걸릴 수 있습니다.</li></ul><h2 id="멱등성은-어떻게-유지하는가"><a href="#멱등성은-어떻게-유지하는가" class="headerlink" title="멱등성은 어떻게 유지하는가?"></a>멱등성은 어떻게 유지하는가?</h2><p>멱등성이란, 같은 작업을 여러 번 수행해도 결과가 변하지 않는 성질을 말합니다. 스프링 배치에서는 이러한 멱등성을 유지하기 위해 여러 가지 방법을 제공합니다. 예를 들어, 아래와 같은 방법으로 멱등성을 유지할 수 있습니다.</p><ul><li>BatchStatus 컬럼을 이용하여 이미 성공한 작업은 다시 수행하지 않도록 합니다.</li><li>JobInstance와 JobExecution의 ID를 이용하여 이미 실행한 작업을 식별하고 중복 실행을 방지합니다.</li></ul><h2 id="스프링-배치-메타데이터-테이블은-어떤-것이-있나"><a href="#스프링-배치-메타데이터-테이블은-어떤-것이-있나" class="headerlink" title="스프링 배치 메타데이터 테이블은 어떤 것이 있나?"></a>스프링 배치 메타데이터 테이블은 어떤 것이 있나?</h2><p>스프링 배치에서는 배치 작업의 메타데이터를 저장하기 위한 테이블을 제공합니다. 이 테이블은 JobRepository 인터페이스를 통해 접근할 수 있습니다. 스프링 배치가 제공하는 기본 메타데이터 테이블은 다음과 같습니다.</p><ul><li>BATCH_JOB_INSTANCE: JobInstance 정보를 저장합니다.</li><li>BATCH_JOB_EXECUTION: JobExecution 정보를 저장합니다.</li><li>BATCH_JOB_EXECUTION_CONTEXT: JobExecution의 ExecutionContext 정보를 저장합니다.</li><li>BATCH_STEP_EXECUTION: StepExecution 정보를 저장합니다.</li><li>BATCH_JOB_PARAMS: Job 파라미터 정보를 저장합니다.</li><li>BATCH_STEP_EXECUTION_CONTEXT: StepExecution의 ExecutionContext 정보를 저장합니다.</li></ul><h2 id="배치-실행-도중-실패시-처리-방법"><a href="#배치-실행-도중-실패시-처리-방법" class="headerlink" title="배치 실행 도중 실패시 처리 방법?"></a>배치 실행 도중 실패시 처리 방법?</h2><p>스프링 배치에서 배치 실행 도중 실패한 경우, 실패한 스텝을 재시도하거나 다음 스텝으로 진행하지 않고 중단하는 등의 처리 방법을 선택할 수 있습니다. 이러한 처리 방법을 설정하기 위해서는 Retry와 Skip 기능을 이용할 수 있습니다.</p><ul><li>Retry: 스텝이 실패한 경우 지정된 횟수만큼 재시도합니다. 예를 들어, ItemReader에서 데이터를 읽어올 때 DB 커넥션 오류 등으로 인해 실패한 경우, 일정 시간이 지난 후에 다시 시도합니다.</li><li>Skip: 스텝이 실패한 경우, 실패한 데이터를 스킵하고 다음 데이터로 넘어갑니다. 이를 이용하여, 예외가 발생해도 작업이 중단되지 않도록 할 수 있습니다.</li></ul><h2 id="스프링-배치-멀티스레드-파티션-방법과-차이점"><a href="#스프링-배치-멀티스레드-파티션-방법과-차이점" class="headerlink" title="스프링 배치 멀티스레드, 파티션 방법과 차이점"></a>스프링 배치 멀티스레드, 파티션 방법과 차이점</h2><p>스프링 배치에서 멀티스레드와 파티션 방법은 모두 대량의 데이터를 처리하는 데 사용됩니다. 멀티스레드는 스텝 내에서 다수의 스레드를 사용하여 처리 속도를 높이는 방법이고, 파티션 방법은 여러 개의 작은 작업 단위로 분할하여 병렬 처리하는 방법입니다. 두 방법의 차이점은 다음과 같습니다.</p><ul><li>멀티스레드: 스텝 내에서 스레드를 사용하여 처리합니다. 하나의 스텝을 여러 개의 스레드로 분할하여 처리할 수 있습니다. 처리 속도를 높일 수 있으나, 스레드 간의 동기화 문제나 데드락 등의 문제가 발생할 수 있습니다.</li><li>파티션: 대량의 데이터를 작은 단위로 나누어 여러 개의 스텝으로 분할하여 처리합니다. 각각의 스텝은 병렬로 처리됩니다. 데이터 분할이 복잡하고 처리 과정에서 추가적인 오버헤드가 발생할 수 있습니다.</li></ul><h2 id="스프링배치에서-트랜잭션-관리를-왜-청크-단위로-하는지"><a href="#스프링배치에서-트랜잭션-관리를-왜-청크-단위로-하는지" class="headerlink" title="스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지"></a>스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지</h2><p>스프링 배치에서 트랜잭션 관리는 청크 단위로 수행됩니다. 이는 대량의 데이터를 처리할 때 메모리 부족 현상을 방지하고, 롤백 시에도 데이터 일관성을 유지하기 위한 것입니다. 예를 들어, 10000건의 데이터를 처리하는데 트랜잭션 범위를 1건 단위로 처리하면, 10000번의 INSERT 작업마다 커밋을 수행해야 합니다. 이는 DB나 메모리 등에서 성능 저하를 일으킬 수 있으며, 롤백 시에도 일부 데이터만 롤백되어 데이터 일관성이 깨질 가능성이 있습니다. 하지만 청크 단위로 처리하면, 1000건 단위로 처리하면 10번의 INSERT 작업마다 커밋을 수행하므로 성능 저하 문제가 줄어들고, 롤백 시에도 청크 단위로 롤백되어 데이터 일관성이 유지됩니다.</p><h2 id="테스킷-vs-Reader-x2F-Writer-차이"><a href="#테스킷-vs-Reader-x2F-Writer-차이" class="headerlink" title="테스킷 vs Reader&#x2F;Writer 차이"></a>테스킷 vs Reader&#x2F;Writer 차이</h2><p>테스킷(Tasklet)과 Reader&#x2F;Writer는 스프링 배치에서 데이터 처리를 위해 사용되는 두 가지 방법입니다. 테스킷은 간단한 처리를 수행하고 스텝을 종료할 때 사용되는 반면, Reader&#x2F;Writer는 대량의 데이터 처리를 위해 사용됩니다.</p><ul><li>테스킷: 스텝 내에서 수행되는 단일 작업입니다. 스텝 시작 시 한 번만 실행되며, 간단한 데이터 처리를 수행합니다. 예를 들어, 파일을 이동하거나, 이메일을 발송하는 등의 작업을 수행할 수 있습니다.</li><li>Reader&#x2F;Writer: 대량의 데이터 처리를 위해 사용됩니다. Reader는 데이터를 읽어오고, Writer는 데이터를 저장합니다. 예를 들어, 데이터베이스에서 대량의 데이터를 읽어와서 파일로 저장하는 등의 작업을 수행할 수 있습니다.</li></ul><h2 id="배치-실행은-젠킨스-실행-및-스케쥴링-관점으로"><a href="#배치-실행은-젠킨스-실행-및-스케쥴링-관점으로" class="headerlink" title="배치 실행은? 젠킨스(실행 및 스케쥴링) 관점으로"></a>배치 실행은? 젠킨스(실행 및 스케쥴링) 관점으로</h2><p>젠킨스에서 스프링 배치를 실행하고 스케줄링하는 방법은 다음과 같습니다.</p><ol><li>젠킨스 홈페이지에 접속합니다.</li><li>젠킨스 대시보드에서 “새로운 Item 생성” 버튼을 클릭합니다.</li><li>“스프링 배치 프로젝트”를 선택합니다.</li><li>필요한 설정을 입력합니다. (프로젝트 이름, 저장소, 빌드 설정 등)</li><li>“빌드 유발” 탭에서 “정기적으로 빌드”를 선택하고, 스케줄링을 설정합니다.</li><li>“빌드” 탭에서 스프링 배치를 실행하는 명령어를 입력합니다. (예: java -jar batch.jar)</li></ol><h2 id="배치-보니터링-방법은-지연되는-배치-등-모니터링-및-후속-처리-관점으로"><a href="#배치-보니터링-방법은-지연되는-배치-등-모니터링-및-후속-처리-관점으로" class="headerlink" title="배치 보니터링 방법은? 지연되는 배치 등 모니터링 및 후속 처리 관점으로"></a>배치 보니터링 방법은? 지연되는 배치 등 모니터링 및 후속 처리 관점으로</h2><p>스프링 배치의 모니터링 및 후속 처리는 스프링 배치가 제공하는 JobExplorer를 이용하여 수행할 수 있습니다. JobExplorer는 배치 작업의 상태를 조회하고, 재시작 및 중지 등의 제어를 수행할 수 있습니다. JobExplorer를 이용하여 지연되는 배치 작업 등을 모니터링하고, 후속 처리를 수행할 수 있습니다. 예를 들어, 아래와 같은 방법으로 JobExplorer를 이용하여 배치 작업을 모니터링할 수 있습니다.</p><ol><li>JobExplorer를 이용하여 JobInstance와 JobExecution 정보를 조회합니다.</li><li>조회한 정보를 이용하여 JobExecution의 상태를 확인하고, 작업이 지연되었는지 확인합니다.</li><li>작업이 지연되었을 경우, 작업을 재시작하거나 중지하는 등의 후속 처리를 수행합니다.</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>이진탐색트리</title>
      <link href="/exploreHA/2023/04/13/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/"/>
      <url>/exploreHA/2023/04/13/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/</url>
      
        <content type="html"><![CDATA[<p>이진 탐색 트리(Binary Search Tree)는 이진 트리(Binary Tree)의 한 종류로서, 각 노드가 하나의 키(Key)를 저장하는 자료 구조입니다. 이진 탐색 트리는 다음과 같은 특성을 가지고 있습니다.</p><ul><li>루트 노드를 기준으로 왼쪽 서브트리의 키는 모두 루트 노드의 키보다 작습니다.</li><li>루트 노드를 기준으로 오른쪽 서브트리의 키는 모두 루트 노드의 키보다 큽니다.</li><li>왼쪽 서브트리와 오른쪽 서브트리도 모두 이진 탐색 트리여야 합니다.</li><li>중복된 키를 가지지 않습니다.</li><li>이진 탐색 트리에서는 탐색, 삽입, 삭제 연산을 O(log n)의 시간 복잡도로 수행할 수 있습니다. 이진 탐색 트리는 탐색이나 삽입, 삭제 연산을 할 때, 항상 트리의 루트 노드부터 시작하여 탐색하므로 탐색 범위를 빠르게 줄일 수 있습니다.</li></ul><p>이진 탐색 트리는 정렬된 데이터의 삽입&#x2F;삭제&#x2F;검색에 적합한 자료 구조입니다. 하지만 트리의 구조가 한쪽으로 치우칠 경우, 트리의 높이가 길어져 연산 속도가 떨어지는 문제가 있습니다. 이러한 문제를 해결하기 위해 AVL 트리, 레드-블랙 트리 등의 균형 이진 탐색 트리가 개발되었습니다.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>treeset 과 hashset 의 차이</title>
      <link href="/exploreHA/2023/04/13/treeset-%EA%B3%BC-hashset-%EC%9D%98-%EC%B0%A8%EC%9D%B4/"/>
      <url>/exploreHA/2023/04/13/treeset-%EA%B3%BC-hashset-%EC%9D%98-%EC%B0%A8%EC%9D%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>내부적으로 해시 테이블을 사용하여 데이터를 저장합니다.<br>데이터의 중복을 허용하지 않습니다.<br>데이터의 순서가 보장되지 않습니다.<br>삽입, 삭제, 검색 시 O(1)의 시간 복잡도를 갖습니다.<br>순서가 중요하지 않은 데이터의 집합에 적합합니다.</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>내부적으로 이진 검색 트리를 사용하여 데이터를 저장합니다.<br>데이터의 중복을 허용하지 않습니다.<br>데이터의 순서가 정렬된 상태로 저장되며, 이진 검색 트리를 사용하기 때문에 검색 속도가 빠릅니다.<br>삽입, 삭제, 검색 시 O(log n)의 시간 복잡도를 갖습니다.<br>순서가 중요하거나, 정렬된 데이터의 집합에 적합합니다.<br>따라서, HashSet은 데이터의 순서가 중요하지 않을 때 사용하고, TreeSet은 데이터의 순서가 중요하거나 정렬된 데이터의 집합에서 사용하는 것이 적합합니다. TreeSet은 검색 속도가 빠르지만, 데이터의 크기가 커질수록 검색 속도가 느려질 수 있습니다. HashSet은 검색 속도가 일정하며, 데이터의 크기가 커져도 검색 속도에 큰 변화가 없습니다.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>List, Set, Map의 차이와 선택방법</title>
      <link href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80-2/"/>
      <url>/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80-2/</url>
      
        <content type="html"><![CDATA[<h2 id="종류-별-특징"><a href="#종류-별-특징" class="headerlink" title="종류 별 특징"></a>종류 별 특징</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List는 순서가 있는 데이터의 집합입니다. 데이터의 중복을 허용합니다. 대표적인 구현 클래스로는 ArrayList, LinkedList, Vector가 있습니다.</p><p>ArrayList: 내부적으로 배열을 사용하여 데이터를 저장합니다. 데이터 추가&#x2F;삭제 시 기존 데이터를 복사하거나 이동해야 하는 단점이 있습니다. 대용량 데이터의 경우 불리할 수 있습니다.<br>LinkedList: 데이터를 연결 리스트로 구현하여 저장합니다. 데이터 추가&#x2F;삭제 시 다른 데이터를 영향받지 않으며, 데이터의 위치를 이동시키는 것이 간단합니다.<br>Vector: ArrayList와 유사하지만, 멀티스레드 환경에서 동기화된 메서드를 제공합니다. 대부분의 경우 ArrayList를 대신하여 사용됩니다.</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set은 순서가 없는 데이터의 집합입니다. 데이터의 중복을 허용하지 않습니다. 대표적인 구현 클래스로는 HashSet, TreeSet이 있습니다.</p><p>HashSet: 내부적으로 HashMap을 사용하여 데이터를 저장합니다. 데이터의 중복을 허용하지 않으며, 순서가 없습니다. 검색 속도가 빠릅니다.<br>TreeSet: 데이터를 정렬하여 저장합니다. 데이터의 중복을 허용하지 않으며, 오름차순이나 내림차순으로 데이터를 정렬할 수 있습니다.</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map은 key-value 쌍으로 이루어진 데이터의 집합입니다. key는 중복될 수 없으며, value는 중복될 수 있습니다. 대표적인 구현 클래스로는 HashMap, TreeMap이 있습니다.</p><p>HashMap: 내부적으로 해시 테이블을 사용하여 key-value 쌍을 저장합니다. key의 중복을 허용하지 않으며, 순서가 없습니다. 검색 속도가 빠릅니다.<br>TreeMap: 데이터를 정렬하여 key-value 쌍을 저장합니다. key의 중복을 허용하지 않으며, 오름차순이나 내림차순으로 데이터를 정렬할 수 있습니다.</p><h2 id="종류-별-선택방법"><a href="#종류-별-선택방법" class="headerlink" title="종류 별 선택방법"></a>종류 별 선택방법</h2><h6 id="1-데이터의-종류와-크기에-따라-선택하기"><a href="#1-데이터의-종류와-크기에-따라-선택하기" class="headerlink" title="1. 데이터의 종류와 크기에 따라 선택하기"></a>1. 데이터의 종류와 크기에 따라 선택하기</h6><pre><code>데이터의 종류와 크기에 따라 적절한 컬렉션 클래스를 선택하는 것이 중요합니다. 예를 들어, 원소의 개수가 많은 경우에는 검색 속도가 빠른 HashSet이나 HashMap을 사용하는 것이 좋습니다.</code></pre><h6 id="2-데이터의-추가-x2F-삭제-빈도에-따라-선택하기"><a href="#2-데이터의-추가-x2F-삭제-빈도에-따라-선택하기" class="headerlink" title="2. 데이터의 추가&#x2F;삭제 빈도에 따라 선택하기"></a>2. 데이터의 추가&#x2F;삭제 빈도에 따라 선택하기</h6><pre><code>데이터의 추가/삭제 빈도에 따라 LinkedList나 TreeSet을 선택할 수 있습니다. 데이터의 추가/삭제가 빈번하게 일어나는 경우, LinkedList는 다른 데이터를 영향받지 않아 데이터 처리 속도가 빠릅니다. TreeSet은 데이터의 추가/삭제가 적은 경우에 사용할 수 있으며, 데이터를 정렬하여 저장하기 때문에 검색 속도가 빠릅니다.</code></pre><h6 id="3-데이터의-정렬-여부에-따라-선택하기"><a href="#3-데이터의-정렬-여부에-따라-선택하기" class="headerlink" title="3. 데이터의 정렬 여부에 따라 선택하기"></a>3. 데이터의 정렬 여부에 따라 선택하기</h6><pre><code>데이터의 정렬 여부에 따라 ArrayList나 LinkedList, TreeSet을 선택할 수 있습니다. 데이터가 정렬되어 있지 않은 경우에는 ArrayList나 LinkedList를 사용하는 것이 좋습니다. TreeSet은 데이터를 정렬하여 저장하기 때문에 정렬된 데이터를 사용할 때 효과적입니다.</code></pre><h6 id="4-동기화-여부에-따라-선택하기"><a href="#4-동기화-여부에-따라-선택하기" class="headerlink" title="4. 동기화 여부에 따라 선택하기"></a>4. 동기화 여부에 따라 선택하기</h6><pre><code>멀티스레드 환경에서는 동기화된 컬렉션 클래스를 사용해야 합니다. 동기화된 컬렉션 클래스로는 Vector, Hashtable, synchronizedList, synchronizedSet, ConcurrentHashMap 등이 있습니다. 멀티스레드 환경에서는 동시성 문제가 발생할 수 있으므로, 이를 고려하여 적절한 컬렉션 클래스를 선택해야 합니다.</code></pre><h6 id="5-데이터의-검색-빈도에-따라-선택하기"><a href="#5-데이터의-검색-빈도에-따라-선택하기" class="headerlink" title="5. 데이터의 검색 빈도에 따라 선택하기"></a>5. 데이터의 검색 빈도에 따라 선택하기</h6><pre><code>데이터의 검색 빈도에 따라 HashMap, TreeMap, LinkedHashMap 중 하나를 선택할 수 있습니다. 검색 속도가 빠른 HashMap은 데이터의 순서가 중요하지 않은 경우에 유용합니다. 순서가 중요한 경우에는 TreeMap이나 LinkedHashMap를 사용하는 것이 좋습니다.</code></pre><h6 id="6-쓰레드-안전-여부에-따라-선택하기"><a href="#6-쓰레드-안전-여부에-따라-선택하기" class="headerlink" title="6. 쓰레드 안전 여부에 따라 선택하기"></a>6. 쓰레드 안전 여부에 따라 선택하기</h6><pre><code>쓰레드 안전 여부에 따라 ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet 등의 컬렉션 클래스를 선택할 수 있습니다. 이들은 멀티스레드 환경에서 안전하게 사용할 수 있습니다.</code></pre><h6 id="7-메모리-사용량과-성능에-따라-선택하기"><a href="#7-메모리-사용량과-성능에-따라-선택하기" class="headerlink" title="7. 메모리 사용량과 성능에 따라 선택하기"></a>7. 메모리 사용량과 성능에 따라 선택하기</h6><pre><code>메모리 사용량과 성능에 따라 ArrayList나 LinkedList, HashSet나 TreeSet, HashMap나 TreeMap 중 하나를 선택할 수 있습니다. 메모리 사용량이 적은 ArrayList나 HashSet을 사용하면 속도가 빨라질 수 있습니다. 대용량 데이터를 다룰 때는 LinkedList나 TreeSet, TreeMap을 사용하는 것이 좋습니다.</code></pre><h6 id="8-컬렉션의-특징에-따라-선택하기"><a href="#8-컬렉션의-특징에-따라-선택하기" class="headerlink" title="8. 컬렉션의 특징에 따라 선택하기"></a>8. 컬렉션의 특징에 따라 선택하기</h6><pre><code>컬렉션의 특징에 따라 선택하는 것도 중요합니다. 예를 들어, ArrayList는 순차적인 데이터 처리에 유용하며, HashSet은 중복 데이터 처리에 유용합니다. 이러한 특징을 고려하여 적절한 컬렉션 클래스를 선택하는 것이 좋습니다.</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>자바 기술 면접 답변 1</title>
      <link href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80/"/>
      <url>/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String은-왜-불변객체인가요"><a href="#1-String은-왜-불변객체인가요" class="headerlink" title="1. String은 왜 불변객체인가요?"></a>1. String은 왜 불변객체인가요?</h3><p>String은 불변객체(immutable object)입니다. 즉, 한번 생성된 String 객체는 내부의 값이 변경될 수 없습니다. 이는 String 객체의 내용이 변경되지 않도록 보장하기 위해서입니다. 만약 String 객체가 변경되면 다른 객체에서도 해당 값에 접근하는 것이 불안정해지기 때문입니다.</p><h3 id="2-접근제어자의-종류와-특징"><a href="#2-접근제어자의-종류와-특징" class="headerlink" title="2. 접근제어자의 종류와 특징?"></a>2. 접근제어자의 종류와 특징?</h3><p>자바에서 접근제어자(access modifier)는 클래스, 필드, 메서드 등의 멤버에 대한 접근 권한을 제어합니다. 다음은 접근제어자의 종류와 특징입니다.</p><p>public: 어떤 클래스에서도 접근 가능합니다.<br>protected: 같은 패키지에서는 접근 가능하고, 다른 패키지의 자식 클래스에서도 접근 가능합니다.<br>default(package-private): 같은 패키지에서만 접근 가능합니다.<br>private: 같은 클래스에서만 접근 가능합니다.</p><h3 id="3-OOP의-4가지-특징"><a href="#3-OOP의-4가지-특징" class="headerlink" title="3. OOP의 4가지 특징?"></a>3. OOP의 4가지 특징?</h3><p>OOP(Object-Oriented Programming)의 4가지 특징은 다음과 같습니다.</p><p>캡슐화(encapsulation): 객체의 상태와 행동을 하나의 단위로 묶고 외부에서의 접근을 제어합니다.<br>상속(inheritance): 상위 클래스의 속성과 메서드를 하위 클래스에서 재사용할 수 있도록 합니다.<br>다형성(polymorphism): 같은 타입 또는 같은 인터페이스를 구현하는 객체들이 동일한 메서드를 호출하여 다른 방식으로 동작할 수 있도록 합니다.<br>추상화(abstraction): 객체의 복잡한 구조와 동작을 간단한 모델로 단순화하여 표현합니다.</p><h3 id="4-캡슐화와-은닉화의-특징"><a href="#4-캡슐화와-은닉화의-특징" class="headerlink" title="4. 캡슐화와 은닉화의 특징?"></a>4. 캡슐화와 은닉화의 특징?</h3><p>캡슐화와 은닉화는 객체지향 프로그래밍에서 데이터 보호와 관련된 개념입니다.</p><p>캡슐화(encapsulation): 객체의 상태와 행동을 하나의 단위로 묶고, 외부에서의 접근을 제어합니다. 캡슐화를 통해 객체의 내부 구현과 상태를 보호하고, 객체 간의 결합도를 낮춰 유지보수와 확장성을 높일 수 있습니다.<br>은닉화(data hiding): 객체의 내부 구현을 외부에 노출하지 않는 것입니다. 객체의 내부 데이터를 외부에서 직접 접근하지 못하도록 하여 데이터 보호함으로써 객체의 무결성을 보장하고, 객체의 내부 구현을 변경해도 외부 인터페이스를 유지할 수 있습니다. 은닉화를 통해 객체의 내부 구현을 감추고, 외부에서는 객체의 인터페이스를 통해 상호작용할 수 있습니다.</p><h3 id="5-OOP의-5대-원칙"><a href="#5-OOP의-5대-원칙" class="headerlink" title="5. OOP의 5대 원칙?"></a>5. OOP의 5대 원칙?</h3><p>OOP의 5대 원칙(SOLID)은 다음과 같습니다.</p><p>SRP(Single Responsibility Principle): 클래스는 하나의 책임만 가져야 합니다.<br>OCP(Open-Closed Principle): 확장에는 열려있고, 변경에는 닫혀있어야 합니다.<br>LSP(Liskov Substitution Principle): 하위 클래스는 상위 클래스를 대체할 수 있어야 합니다.<br>ISP(Interface Segregation Principle): 인터페이스는 클라이언트에 필요한 메서드만 제공해야 합니다.<br>DIP(Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존하지 않아야 합니다.</p><h3 id="6-JVM-구조"><a href="#6-JVM-구조" class="headerlink" title="6. JVM 구조?"></a>6. JVM 구조?</h3><p>JVM(Java Virtual Machine)은 자바 프로그램을 실행하는 가상 머신입니다. JVM은 3가지 구성 요소로 이루어져 있습니다.</p><p>Class Loader: 컴파일된 자바 클래스 파일을 메모리에 로딩합니다.<br>Execution Engine: 로딩된 클래스 파일을 실행합니다.<br>Runtime Data Areas: JVM에서 메모리를 관리하는 영역으로, Method Area, Heap, Java Stack, Native Stack 등으로 구성됩니다.</p><h3 id="7-클래스-객체-인스턴스의-차이"><a href="#7-클래스-객체-인스턴스의-차이" class="headerlink" title="7. 클래스, 객체, 인스턴스의 차이?"></a>7. 클래스, 객체, 인스턴스의 차이?</h3><p>클래스는 객체를 만들기 위한 일종의 설계도이며, 객체는 클래스를 통해 생성된 실체입니다. 인스턴스는 객체가 메모리에 할당된 상태를 의미합니다.</p><h3 id="8-interface와-abstract-class의-차이"><a href="#8-interface와-abstract-class의-차이" class="headerlink" title="8. interface와 abstract class의 차이?"></a>8. interface와 abstract class의 차이?</h3><p>interface와 abstract class는 모두 추상화를 위한 개념입니다. 다음은 둘의 차이점입니다.</p><p>interface는 모든 메서드가 추상 메서드이며, 구현부를 가질 수 없습니다. 반면, abstract class는 추상 메서드와 구현된 메서드를 모두 포함할 수 있습니다.<br>interface는 다중 상속이 가능합니다. 반면, abstract class는 단일 상속만 가능합니다.<br>interface는 클래스에서 implements 키워드를 사용하여 구현합니다. 반면, abstract class는 extends 키워드를 사용하여 상속합니다.</p><h3 id="9-CheckedException과-UncheckedException의-차이"><a href="#9-CheckedException과-UncheckedException의-차이" class="headerlink" title="9. CheckedException과 UncheckedException의 차이?"></a>9. CheckedException과 UncheckedException의 차이?</h3><p>CheckedException은 예외 처리가 강제되는 예외입니다. 컴파일 시점에서 예외 처리를 확인하며, 예외를 처리하지 않으면 코드를 컴파일할 수 없습니다. 대표적인 예로는 IOException, ClassNotFoundException 등이 있습니다. 반면, UncheckedException은 예외 처리가 강제되지 않는 예외입니다. 컴파일 시점에서 확인하지 않으며, 런타임 시점에서 예외가 발생합니다. 대표적인 예로는 NullPointerException, ArrayIndexOutOfBoundsException 등이 있습니다.</p><h3 id="10-Call-by-Reference와-Call-by-Value의-차이"><a href="#10-Call-by-Reference와-Call-by-Value의-차이" class="headerlink" title="10. Call by Reference와 Call by Value의 차이?"></a>10. Call by Reference와 Call by Value의 차이?</h3><p>Call by Value는 메서드 호출 시 인자로 전달된 값의 복사본을 생성하여 사용합니다. 메서드 내부에서 복사본을 변경해도 원본 값에는 영향을 주지 않습니다. 반면, Call by Reference는 메서드 호출 시 인자로 전달된 값의 메모리 주소를 참조합니다. 따라서 메서드 내부에서 값이 변경되면 원본 값에도 영향을 주게 됩니다.</p><h3 id="11-오버로딩과-오버라이딩의-차이"><a href="#11-오버로딩과-오버라이딩의-차이" class="headerlink" title="11. 오버로딩과 오버라이딩의 차이?"></a>11. 오버로딩과 오버라이딩의 차이?</h3><p>오버로딩(Overloading)은 같은 이름의 메서드를 여러 개 정의하는 것을 말합니다. 매개변수의 개수, 타입, 순서가 다르면 오버로딩이 가능합니다. 반면, 오버라이딩(Overriding)은 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하는 것을 말합니다. 메서드의 시그니처(이름, 매개변수 타입, 반환 타입)가 동일해야 합니다.</p><h3 id="12-스레드세이프-Thread-Safe"><a href="#12-스레드세이프-Thread-Safe" class="headerlink" title="12. 스레드세이프(Thread-Safe)"></a>12. 스레드세이프(Thread-Safe)</h3><p>스레드세이프란 여러 스레드가 동시에 접근해도 안전하게 사용할 수 있는 코드를 말합니다. 스레드세이프한 코드는 멀티스레드 환경에서 동시성 문제를 방지하고, 데이터의 일관성을 유지합니다.</p><h3 id="13-Garbage-Collector는-어떻게-동작하는지"><a href="#13-Garbage-Collector는-어떻게-동작하는지" class="headerlink" title="13. Garbage Collector는 어떻게 동작하는지?"></a>13. Garbage Collector는 어떻게 동작하는지?</h3><p>Garbage Collector는 JVM에서 사용되지 않는 객체를 자동으로 해제하는 기능입니다. Garbage Collector는 객체가 생성된 시점, 참조되지 않는 시점 등을 추적하여 사용되지 않는 객체를 메모리에서 해제합니다.</p><h3 id="14-제네릭을-왜-쓰는지"><a href="#14-제네릭을-왜-쓰는지" class="headerlink" title="14. 제네릭을 왜 쓰는지?"></a>14. 제네릭을 왜 쓰는지?</h3><p>제네릭은 자바에서 컬렉션의 타입 안정성을 보장하기 위해 사용됩니다. 제네릭을 사용하면 컬렉션에 저장된 요소의 타입을 컴파일 시점에 확인할 수 있으며, 타입안정성이 높아집니다. 또한 제네릭은 코드의 재사용성을 높여줍니다. 제네릭을 사용하면 같은 코드를 여러 타입에서 사용할 수 있기 때문입니다.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>자바 기술면접 질문목록</title>
      <link href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D-1/"/>
      <url>/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D-1/</url>
      
        <content type="html"><![CDATA[<h2 id="자바"><a href="#자바" class="headerlink" title="자바"></a>자바</h2><ol><li>String 은 왜 불변객체인가 ? </li><li>접근제어자의 종류와 특징 ? </li><li>OOP 의 4가지 특징 ? </li><li>캡슐화와 은닉화의 특징 ? </li><li>OOP의 5대 원칙 ? </li><li>JVM 구조</li><li>클래스, 객체, 인스턴스의 차이</li><li>interface와 abstract class의 차이</li><li>checkedException 과 uncheckedException의 차이</li><li>Call by Reference 와 Call by value 의 차이</li><li>오버로딩과 오버라이딩의 차이</li><li>쓰레드세이프</li><li>Garbage Collector는 어떻게 동작하는지 ? </li><li>제네릭을 왜 쓰는지 ? </li><li>list, set, map 의 차이</li><li>이진탐색트리란 ? </li><li>treeset 과 hashset 의 차이</li></ol><h2 id="자바-배치"><a href="#자바-배치" class="headerlink" title="자바 배치"></a>자바 배치</h2><ol><li>왜 스프링 배치를 사용하는가?</li></ol><ul><li>해당 기술 사용 선택 기준사한, 장단점</li></ul><ol start="2"><li>멱등성은 어떻게 유지하는가</li><li>스프링 배치 메타데이터 테이블은 어떤 것이 있나</li><li>배치 실행 도중 실패시 처리 방법</li></ol><ul><li>Skip, Retry 개념 및 사용 경험</li></ul><ol start="5"><li>스프링 배치 멀티스레드, 파티션 방법과 차이점 </li><li>스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지 </li><li>테스킷 ve Reader&#x2F;Write 차이</li><li>커서 vs 페이징 차이, 사용 클래스 </li><li>배치 실행은?</li></ol><ul><li>젠킨스(실행 및 스케쥴링)</li></ul><ol start="10"><li>배치 보니터링 방법</li></ol><ul><li>지연되는 배치 등 모니처링 및 후속 처리</li></ul><h2 id="자바-스프링부트"><a href="#자바-스프링부트" class="headerlink" title="자바 스프링부트"></a>자바 스프링부트</h2><ol><li>필터와 인터셉터의 차이</li><li>스프링부트는 왜 생긴것인가? </li><li>스프링 DI 란 무엇인가 ? </li><li>스프링 IOC 란 무엇인가 ? </li><li>스프링 ORM 이란 무엇인가 ?</li><li>Hibernate 란 무엇인가 ? </li><li>객체 주입방식 종류와 특징, 차이점</li><li>스프링 MVC life cycle 구조</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression in Java</title>
      <link href="/exploreHA/2023/04/04/Regular%20Expression%20in%20Java/"/>
      <url>/exploreHA/2023/04/04/Regular%20Expression%20in%20Java/</url>
      
        <content type="html"><![CDATA[<h1 id="Regular-Expression-to-Format-a-Number-String"><a href="#Regular-Expression-to-Format-a-Number-String" class="headerlink" title="Regular Expression to Format a Number String"></a>Regular Expression to Format a Number String</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We discussed a regular expression used to format a number string by adding commas every three digits. The regular expression is <code>(\d)(?=(?:\d&#123;3&#125;)+(?!\d))</code> and it is used with the <code>replace</code> method in JavaScript to add commas to the number string.</p><h2 id="Regular-Expression-Breakdown"><a href="#Regular-Expression-Breakdown" class="headerlink" title="Regular Expression Breakdown"></a>Regular Expression Breakdown</h2><p>We broke down the regular expression into its components:</p><ul><li><code>(\d)</code>: This is a capture group that matches any single digit.</li><li><code>(?=...)</code>: This is a positive lookahead that matches the following pattern without including it in the match.</li><li><code>(?:...)</code>: This is a non-capturing group that groups together the following pattern without creating a capture group.</li><li><code>\d&#123;3&#125;</code>: This matches any three digits.</li><li><code>+</code>: This matches one or more of the previous pattern.</li><li><code>(?!\d)</code>: This is a negative lookahead that matches the following pattern only if it is not followed by a digit.</li></ul><h2 id="Regular-Expression-Explanation"><a href="#Regular-Expression-Explanation" class="headerlink" title="Regular Expression Explanation"></a>Regular Expression Explanation</h2><p>We explained that the regular expression matches any single digit that is followed by one or more groups of three digits that are not followed by a digit. This effectively matches every digit in the number string except for the ones at the end that are not part of a group of three.</p><h2 id="Example-Process"><a href="#Example-Process" class="headerlink" title="Example Process"></a>Example Process</h2><p>We provided an example process to demonstrate how the regular expression works. Suppose we have the number string “1000000000”. The regular expression matches the first digit “1” because it is followed by a group of three digits “000”. It then matches the second digit “0” because it is followed by another group of three digits “000”. It continues to match every digit in the number string that is followed by a group of three digits. When it reaches the end of the string, it stops matching because the last digit “0” is not followed by a group of three digits.</p><h2 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion 1"></a>Conclusion 1</h2><p>We concluded that the regular expression <code>(\d)(?=(?:\d&#123;3&#125;)+(?!\d))</code> can be used to format a number string by adding commas every three digits. The regular expression matches every digit in the string except for the ones at the end that are not part of a group of three.</p><h2 id="More-Techniques"><a href="#More-Techniques" class="headerlink" title="More Techniques"></a>More Techniques</h2><ol><li><p>Negative Lookahead: This is similar to positive lookahead, but it matches if the pattern does NOT occur after the current position. It is denoted by (?!pattern).</p></li><li><p>Capturing Groups with Names: Instead of just using numbered capturing groups like $1, you can assign names to capturing groups for easier reference. For example, (?<year>\d{4}) would match a four-digit number and capture it in the group named “year”.</p></li><li><p>Quantifiers: Quantifiers allow you to specify how many times a character or group should be matched. For example, a{3,5} would match “aaa”, “aaaa”, or “aaaaa”, but not “aa”.</p></li><li><p>Alternation: Alternation allows you to match one pattern OR another. It is denoted by the | symbol. For example, (cat|dog) would match “cat” or “dog”.</p></li><li><p>Character Classes: Character classes allow you to match a range of characters. For example, [a-z] would match any lowercase letter, and [0-9] would match any digit.</p></li><li><p>Non-Capturing Groups: Similar to capturing groups, non-capturing groups allow you to group  parts of the pattern together without capturing the match. This can be useful for improving performance and simplifying the regular expression. Non-capturing groups are denoted by (?:pattern).</p></li><li><p>Anchors: Anchors allow you to match a pattern at a specific position in the string. The most common anchors are ^, which matches the start of a line, and $, which matches the end of a line.</p></li><li><p>Backreferences: Backreferences allow you to match a pattern that was previously matched by a capturing group. This can be useful for finding repeated patterns in a string. Backreferences are denoted by \number, where number is the number of the capturing group you want to reference.</p></li><li><p>Lookbehinds: Lookbehinds are similar to lookaheads, but they match a pattern that precedes the current position in the string. Lookbehinds are denoted by (?&lt;&#x3D;pattern) for a positive lookbehind and (?&lt;!pattern) for a negative lookbehind.</p></li><li><p>Unicode Characters: Regular expressions can match any Unicode character by using escape sequences. For example, \p{L} matches any letter, and \p{N} matches any digit.</p></li><li><p>Character Classes: Character classes allow you to match a single character from a set of characters. They are denoted by square brackets, for example [aeiou] matches any vowel.</p></li><li><p>Alternation: Alternation allows you to match one of several alternatives. It is denoted by the pipe character |. For example, (cat|dog) matches either “cat” or “dog”.</p></li><li><p>Quantifiers: Quantifiers allow you to match a certain number of repetitions of a pattern. The most common quantifiers are * for zero or more, + for one or more, and ? for zero or one.</p></li><li><p>Dot: The dot . matches any character except a newline character.</p></li><li><p>Word Boundaries: Word boundaries allow you to match a pattern only when it appears at the beginning or end of a word. They are denoted by \b.</p></li><li><p>Greedy vs. Lazy Matching: By default, regular expressions are greedy and match as much as possible. You can use a ? after a quantifier to make it lazy and match as little as possible.</p></li><li><p>Character Escapes: Character escapes allow you to match characters that have special meaning in regular expressions. For example, to match a literal dot character, you need to escape it with a backslash: ..</p></li><li><p>Substitution: Regular expressions are often used to replace text. You can use the replace() method to substitute matches with other text.</p></li><li><p>Flags: Regular expressions can have flags that modify their behavior. The most common flags are i for case-insensitive matching and g for global matching.</p></li><li><p>Grouping: Grouping allows you to treat a pattern as a single unit and apply a quantifier to it. Groups are denoted by parentheses, for example a(bc)+ matches “abc”, “abcbc”, “abcbcbc”, and so on.</p></li></ol><h2 id="Conclution-2"><a href="#Conclution-2" class="headerlink" title="Conclution 2"></a>Conclution 2</h2><p>얼마전 코딩테스트 보러갔다가 종이 시험을 보는것을 보고 1차로 놀랐다. 그리곤 문제를 보는데 1번부터 내 머리속에 아무것도 없는것을 느끼고 2차로 놀랐다. IDE의 힘을 빌려 AI HELPER의 빌려 살다보니 그렇다. 특히 정규식같은 부분은 한번 써놓고 오래 보질 않으니 다 휘발되고 머리에 남은게 없었다.<br>그렇게 계속 생각없이 살다가 Fiddler로 결제모듈을 뜯다보니 왠걸 갑자기 내가 정규식이 아닌 리스트로 풀었던 답이 딱 나오길래 글을 남긴다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">amount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;10000000&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedStr</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;(\\d)(?=(?:\\d&#123;3&#125;)+(?!\\d))&quot;</span>, <span class="string">&quot;$1,&quot;</span>);</span><br><span class="line">        <span class="comment">// str의 한글자 한글자를 정규식을 대입해서 일치하면 캡처한 변수 $1로 바꾼다. </span></span><br><span class="line">        <span class="comment">// (\\d): 첫번째 차례인 문자가 숫자인경우, 값을 캡쳐한다. 일치하지않으면 다음 차례 문자를 검사한다. </span></span><br><span class="line">        <span class="comment">// (?=) : 전방탐색(positive lookahead)으로 str 끝까지 미리 일치하는지 검사 한다. </span></span><br><span class="line">        <span class="comment">// (?:) : 괄호안에 있어도 캡쳐하지 않는다는 뜻이다.</span></span><br><span class="line">        <span class="comment">// \\d&#123;3&#125;+ : 숫자 3개로 이루어진 세트가 여러개 있는것을 말한다.</span></span><br><span class="line">        <span class="comment">// (?!) : 이 다음이 아닌경우를 찾는다. </span></span><br><span class="line">        <span class="comment">// \\d : 숫자를 뜻한다. </span></span><br><span class="line">        <span class="comment">// 종합: 맨 처음부터 문자 한개를 잡고 그뒤로 숫자 3개가 붙어있는 세트가 쭉 이어지는지 검사한다. 딱 맞아 떨어지면 캡쳐해놓은 맨 처음 숫자에 ,를 더해서 교체한다. </span></span><br><span class="line">        <span class="comment">// 만약 딱 맞아 떨어지지 않으면 그냥 통과한다. </span></span><br><span class="line">        System.out.println(formattedStr);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java, Regular Expression, 정규식 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Questions</title>
      <link href="/exploreHA/2023/02/14/Swift-Questions/"/>
      <url>/exploreHA/2023/02/14/Swift-Questions/</url>
      
        <content type="html"><![CDATA[<ol><li><p>What is the difference between an enumeration and a structure in Swift?</p><p>In Swift, an enumeration (or “enum” for short) is a value type that represents a group of related values. Enums are defined using the <code>enum</code> keyword and can be used to define a set of possible values for a variable, for example, a list of error codes, or a list of days of the week. Enums can also have associated values, which can be used to store additional information for each case.<br>A structure (or “struct” for short) is also a value type in Swift that represents a group of related values, but it can store multiple values of different types, similar to a class. Structures can have properties, methods, and initializers, and they can also conform to protocols.</p><p>요약: 열거형(“Enum”)은 관련 값 그룹 유형이며 값 집합을 정의하는데 사용한다. 구조체(“Struct”)는 관련 값 그룹 인것 맞지만 서로 다른 유형의 여러 값을 저장할 수 있으며, 속성, 메서드, 이니셜라이저를 갖고 프로토콜을 따를 수도 있다. </p></li><li><p>Can you give an example of using optional chaining in Swift?</p><p>Optional chaining in Swift is a way of calling properties, methods, or subscripts on an optional value, where the optional value may be <code>nil</code>. If the optional value is <code>nil</code>, the result of the optional chaining is <code>nil</code>, otherwise, it returns the result of the operation.</p><p>Here’s an example of using optional chaining in Swift:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> city: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">street</span>: <span class="type">String</span>, <span class="params">city</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.street <span class="operator">=</span> street</span><br><span class="line">        <span class="keyword">self</span>.city <span class="operator">=</span> city</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> street <span class="operator">=</span> john.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(street)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;john does not have an address&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">john.address <span class="operator">=</span> <span class="type">Address</span>(street: <span class="string">&quot;Jong-ro&quot;</span>,city: <span class="string">&quot;Seoul&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> street <span class="operator">=</span> john.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(street)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;john does not have an address&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john does not have an address</span><br><span class="line">Jong-ro</span><br></pre></td></tr></table></figure></li><li><p>What is the purpose of the “defer” statement in Swift?</p><p> The “defer” statement in Swift is used to execute a block of code just before the current function returns. The code in the “defer” block is executed regardless of how the function returns, whether it returns normally, or due to an exception being thrown.<br> The main use case for the “defer” statement is to perform cleanup tasks, such as freeing up resources, closing files, or releasing locks, even if the function exits early due to an error. This helps to simplify the code by centralizing the cleanup code in a single place and making it easier to understand the code flow.</p><p> 요약: “defer”는 함수 반환 전 정상, 예외 여부와 관계없이 마지막에 실행되는것으로 오류로 인해 조기에 종료되더라도 파일닫기, 잠금해제같은 작업을 수행하기 위함이다. </p><p> Here’s an example of using the “defer” statement in Swift:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">processFile</span>(<span class="params">fileName</span>: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> file <span class="operator">=</span> <span class="keyword">try</span> openFile(fileName)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        closeFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// perform some processing on the file</span></span><br><span class="line">    <span class="keyword">try</span> processContents(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> In this example, the openFile function is called to open a file, and the closeFile function is called in the defer block to close the file. The closeFile function is guaranteed to be called, even if the processContents function throws an error, because the defer block is executed just before the processFile function returns. This makes it easy to ensure that the file is always closed, even if an error occurs during the processing of the file.</p></li><li><p>What is the difference between a class and a structure in Swift?</p><p> In Swift, a class and a structure are both used to define custom data types, but they have some key differences.<br> Classes are reference types, which means that when you assign a class instance to a variable, you are actually creating a reference to the instance, not a copy of it. This means that multiple variables can refer to the same instance, and changes to the instance made through one reference will be visible through all references.<br> Structures, on the other hand, are value types, which means that when you assign a struct instance to a variable, you are creating a copy of the instance. This means that changes to the instance made through one reference will not affect other references to the same instance.<br> Classes can also inherit from other classes and can be used to create objects, while structures cannot. Structures, however, are generally faster and more efficient than classes, especially when it comes to small instances, and they are also easier to manage and debug because they are self-contained.</p><p> 요약: 구조체, 클래스 모두 데이터 유형 정의에 사용. 클래스를 인스턴스에 할당하면 복제가 아닌 참조를 만드는것이나, 구조는 복사본이 생성된다. 클래스는 다른 클래스에서 상속할 수 있고 객체를 만드는데 사용할 수 있지만 구조체는 그렇지 않다. 인스턴스가 작으면 구조체가 더 효율적일 수 있다. </p></li><li><p>Can you explain the difference between a class method and an instance method in Swift?</p><p> Class methods are called on the class itself, while instance methods are called on instances of the class.<br> Class methods can be called without creating an instance of the class, while instance methods require an instance to be created.<br> Class methods have the class keyword in their declaration, while instance methods do not.</p><p> 클래스 메서드는 클래스 자체에서 인스턴스 할당 없이 호출되는 반면,<br> 인스턴스 메서드는 클래스를 인스턴스에 할당 한 뒤에 그 인스턴스에서 호출된다.</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">displayClassName</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Car&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">displayInstanceName</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Instance of Car&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Car</span>.displayClassName() <span class="comment">// Output: Car</span></span><br><span class="line"><span class="keyword">let</span> myCar <span class="operator">=</span> <span class="type">Car</span>()</span><br><span class="line">myCar.displayInstanceName() <span class="comment">// Output: Instance of Car</span></span><br></pre></td></tr></table></figure></li><li><p>Can you give an example of using generics in Swift?</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sortArray</span>&lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">T</span>]) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> array.sorted()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="keyword">let</span> unsortedInts <span class="operator">=</span> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> sortedInts <span class="operator">=</span> sortArray(unsortedInts)</span><br><span class="line"><span class="built_in">print</span>(sortedInts) <span class="comment">// Output: [2, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unsortedStrings <span class="operator">=</span> [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;bird&quot;</span>, <span class="string">&quot;fish&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> sortedStrings <span class="operator">=</span> sortArray(unsortedStrings)</span><br><span class="line"><span class="built_in">print</span>(sortedStrings) <span class="comment">// Output: [&quot;bird&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;]</span></span><br></pre></td></tr></table></figure><p> 함수 sortArray는 Comparable프로토콜을 따르는 제네릭 타입 T를 사용한다. Comparable을 따른다는것은 비교연산자를 사용할 수 있다는것이다. </p></li><li><p>What is the difference between optional binding and optional chaining in Swift?</p><p> Optional binding is used to safely unwrap an optional value and bind it to a new variable or constant, and it’s typically used when you need to perform operations on the unwrapped value.<br> In this example, we use optional binding with if let to safely unwrap the optional value optionalName and bind it to the new constant name. If the optional value is nil, the code inside the else block will be executed. Here’s an example:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalName: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, stranger.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 옵셔널 바인딩은 안전하게 변수를 언랩하기 위함이다. </p><p> Optional chaining, on the other hand, is used to safely access a property or call a method on an optional value, without needing to first unwrap the value. In this example, we use optional chaining with the ? operator to safely access the street property of the person’s address property. If person.address is nil, the code inside the else block will be executed instead.<br> Here’s an example:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> city: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John&quot;</span>, age: <span class="number">30</span>, address: <span class="type">Address</span>(street: <span class="string">&quot;123 Main St&quot;</span>, city: <span class="string">&quot;Anytown&quot;</span>, state: <span class="string">&quot;CA&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> street <span class="operator">=</span> person.address<span class="operator">?</span>.street &#123; <span class="comment">// &lt;==</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;He lives on <span class="subst">\(street)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No address found.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 반면 옵셔널체이닝은 안전하게 변수에 접근하기 위함이다.</p></li><li><p>Can you explain the difference between class inheritance and protocol-oriented programming in Swift?</p><p> Both class inheritance and protocol-oriented programming are ways to achieve code reuse and polymorphism in Swift, but they have different approaches and trade-offs.</p><p> Class inheritance is a mechanism where a subclass inherits properties and methods from a superclass. The subclass can also override and add its own properties and methods. Class inheritance is a form of vertical code reuse because it defines a hierarchy of classes with shared functionality. </p><p> &#x3D;&gt; 클래스는 일부를 공유하는 계층적 구조이므로 수직적인 상속 형태라고 볼 수 있다. </p><p> In this example, the Cat class inherits from the Animal class, which defines a name and sound property and a makeSound() method. The Cat class overrides the makeSound() method to provide its own implementation.</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> sound: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">sound</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.sound <span class="operator">=</span> sound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">makeSound</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> makes <span class="subst">\(sound)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, sound: <span class="string">&quot;meow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">makeSound</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> purrs.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="type">Cat</span>(name: <span class="string">&quot;Whiskers&quot;</span>)</span><br><span class="line">cat.makeSound() <span class="comment">// Output: &quot;Whiskers purrs.&quot; (Example of overriden func)</span></span><br></pre></td></tr></table></figure><p> Protocol-oriented programming, on the other hand, is a programming paradigm where functionality is defined in small, composable protocols that can be combined to create new types. This is a form of horizontal code reuse because it encourages the creation of many small protocols with specific functionality that can be combined and reused in different ways. </p><p> 다양한 방식으로 결합하고 재사용할 수 있는 작은 프로토콜의 생성&#x3D;&gt; 수평적 코드 재사용</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">move</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">speed</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.speed <span class="operator">=</span> speed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">move</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The car is moving at <span class="subst">\(speed)</span> mph.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span>: <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">speed</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.speed <span class="operator">=</span> speed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">move</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The plane is flying at <span class="subst">\(speed)</span> mph.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>(speed: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> plane <span class="operator">=</span> <span class="type">Plane</span>(speed: <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vehicles: [<span class="type">Movable</span>] <span class="operator">=</span> [car, plane]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> vehicle <span class="keyword">in</span> vehicles &#123;</span><br><span class="line">    vehicle.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> While protocols and class inheritance can achieve similar results in some cases, they have different strengths and use cases.</p><p> One advantage of using protocols is that they allow for greater flexibility and modularity in your code. Protocols can be adopted by a wide range of types, including classes, structs, and enums. This means that you can create more specialized types that conform to a protocol, rather than having to subclass a more general type. This can help avoid issues with tight coupling and inheritance hierarchies that can arise with class inheritance.</p><p> Additionally, protocols can be used to achieve polymorphism across types that don’t share a common superclass. With protocols, you can define a common set of requirements that any conforming type must implement, allowing you to work with a wider range of types that share a particular behavior.</p><p> Another advantage of protocols is that they allow for composition over inheritance. With protocols, you can define small, modular interfaces that can be combined to create larger and more complex behaviors. This can make your code more flexible and easier to maintain, since you can reuse small pieces of functionality in different contexts.</p><p> In summary, while protocols and class inheritance can both achieve code reuse and polymorphism, protocols have different strengths and use cases, including greater flexibility and modularity, better support for polymorphism across different types, and the ability to compose smaller pieces of functionality into larger behaviors.</p><p> &#x3D;&gt; 프로토콜은 더 큰 유연성과 모듈성을 허용하며, 클래스 뿐만 아니라 구조체, 열거형 등에서도 사용하며 하위 클래스로 분류하는게 아닌 프로토콜을 준수하는 유형으로 취급하여 클래스 상속에서 발생할 수 있는 강결합 및 상속 계층 문제를 방지한다.<br> &#x3D;&gt; 클래스 상속과 프로토콜을 동시에 사용이 가능하다.</p></li><li><p>How does Swift handle type casting?</p><p>In Swift, type casting is the process of checking the type of an instance at runtime and converting it to another type if possible. There are two types of type casting in Swift: upcasting and downcasting.</p><p>Upcasting is the process of converting an instance of a subclass to an instance of its superclass. Since a subclass is guaranteed to have all the properties and methods of its superclass, upcasting is always safe in Swift. </p><p>Here’s an example of upcasting and downcasting in Swift:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> school: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">school</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.school <span class="operator">=</span> school</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> school: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">school</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.school <span class="operator">=</span> school</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Upcasting to the Human superclass</span></span><br><span class="line"><span class="keyword">let</span> human: <span class="type">Human</span> <span class="operator">=</span> <span class="type">Teacher</span>(name: <span class="string">&quot;John Doe&quot;</span>, school: <span class="string">&quot;Acme High School&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> human2: <span class="type">Human</span> <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Jimmy Yo&quot;</span>, school: <span class="string">&quot;Batman School&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> humanList <span class="operator">=</span> [<span class="type">Human</span>]()</span><br><span class="line"></span><br><span class="line">humanList.append(human)</span><br><span class="line">humanList.append(human2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Downcasting to the Teacher subclass</span></span><br><span class="line"><span class="keyword">for</span> human <span class="keyword">in</span> humanList &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> teacher <span class="operator">=</span> human <span class="keyword">as?</span> <span class="type">Teacher</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(teacher.name)</span> is teacher&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> student <span class="operator">=</span> human <span class="keyword">as?</span> <span class="type">Student</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(student.name)</span> is student&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(human.name)</span> is something else&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Downcasting is the process of converting an instance of a superclass to an instance of a subclass. Since a superclass does not necessarily have all the properties and methods of its subclasses, downcasting is not always safe in Swift. To perform a downcast safely, you need to use the optional type-casting operator as? or the forced type-casting operator as!.</p><p>&#x3D;&gt; type을 쓰면 어떤 클래스인지 정확하게 알 수 있다.<br>&#x3D;&gt; 업캐스팅은 서브클래스를 어퍼클래스로 취급하고싶을때 사용 (포장)<br>&#x3D;&gt; 다운캐스팅은 업캐스팅된 서브클래스를 다시 서브클래스로 취급하고싶을때 사용 (포장 제거)</p></li><li><p>Can you give an example of using the guard statement in Swift to handle optional values?</p><p>guard. 진짜면 나간다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">name</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> name <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No name provided&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(name: <span class="string">&quot;John&quot;</span>) <span class="comment">// prints &quot;Hello, John!&quot;</span></span><br><span class="line">greet(name: <span class="literal">nil</span>) <span class="comment">// prints &quot;No name provided&quot;</span></span><br></pre></td></tr></table></figure><p>greet 함수는 옵셔널 String을 파라메터로 받는다. 이 함수에서 guard는 name 파라메터가 nil인지 검사하고 조건이 true 이면 gurad를 나가고, false 이면(nil이면) guard 안을 돈다.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Practices</title>
      <link href="/exploreHA/2023/02/07/Swift%20Practices/"/>
      <url>/exploreHA/2023/02/07/Swift%20Practices/</url>
      
        <content type="html"><![CDATA[<p>가. array 배열의 합</p><ol><li>for number in array { sum +&#x3D; number}</li><li>array.reduce(0, { (first:Int, seconde:Int) -&gt; Int in return first + second })</li><li>array.reduce(0){$0+$1}</li><li>array.reduce(0, +)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/exploreHA/2023/01/09/hello-world/"/>
      <url>/exploreHA/2023/01/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO 블로그 복구</title>
      <link href="/exploreHA/2023/01/09/HEXO%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%B3%B5%EA%B5%AC/"/>
      <url>/exploreHA/2023/01/09/HEXO%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%B3%B5%EA%B5%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="블로그-구조-파악"><a href="#블로그-구조-파악" class="headerlink" title="블로그 구조 파악"></a>블로그 구조 파악</h3><p>GitHub Page에서 호스팅 지원</p><p>Hexo 라이브러리로 꾸미기, 배포 지원</p><h3 id="최초-세팅순서"><a href="#최초-세팅순서" class="headerlink" title="최초 세팅순서"></a>최초 세팅순서</h3><ol><li><p>github page 설정</p></li><li><p>github repository 설정(public)</p></li><li><p>node.js설치(패키지 다운로드해서 설치 진행)</p></li><li><p>블로그를 작업할 폴더에서 우클릭해서 git bash 실행</p></li><li><p>git 의 ssh 확인</p></li><li><p>npm install hexo-cli -g 으로 hexo 설치</p></li><li><p>hexo init blog 로 blog 폴더에 관련파일 설치</p></li><li><p>cd blog</p></li><li><p>npm install</p></li><li><p>git clone &lt;레포 주소&gt;</p></li><li><p>npm install –save hexo-deployer-git</p></li><li><p>_config.yml 파일 설정</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">url:</span> </span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//</span></span><br><span class="line"><span class="symbol">  branch:</span> main</span><br></pre></td></tr></table></figure></li><li><p>깃허브에서 repo설정 진입 - pages</p></li><li><p>브랜치 고르고 라이브 페이지 설정하기</p></li><li><p>git bash 로 돌아와서 </p></li><li><p>hexo deploy</p></li></ol><h3 id="여러곳에서-포스팅하려면"><a href="#여러곳에서-포스팅하려면" class="headerlink" title="여러곳에서 포스팅하려면"></a>여러곳에서 포스팅하려면</h3><p>위 과정대로 deploy를 하면 로컬 blog 폴더 내 .deploy_git 내용들이 레포에 올라가게 된다. 그러나 준비에 필요한 나머지 파일이 없으므로 node모듈을 제외한 용량이 적은 리소스들을 전부 .gitignore에서 제외해주고 </p><p>blog 안의 파일 전부를 private 레포에 따로 올려야 한다. 이것을 backup레포라고 한다면</p><h4 id="새로운-장소에서-블로그를-이어가려면"><a href="#새로운-장소에서-블로그를-이어가려면" class="headerlink" title="새로운 장소에서 블로그를 이어가려면"></a>새로운 장소에서 블로그를 이어가려면</h4><ol><li>blog(backup)레포를 로컬과 클론한다.</li><li>아무 폴더에 HEXO 설치 후 node_modules만 blog 폴더에 넣는다.</li><li>npm install –save hexo-deployer-git 설치한다.</li><li>.deploy_git은 날려도 좋다. 문제가 있다면 rm -rf .deploy_git으로 날린뒤</li><li>hexo g -d 로 다시 배포한다.</li><li>clone된 repo도 commit한다.</li></ol><h4 id="새로운-장소에서-이전-테마를-설치하려면-next테마"><a href="#새로운-장소에서-이전-테마를-설치하려면-next테마" class="headerlink" title="새로운 장소에서 이전 테마를 설치하려면(next테마)"></a>새로운 장소에서 이전 테마를 설치하려면(next테마)</h4><ol><li>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2Nz">https://github.com/next-theme/theme-next-docs<i class="fa fa-external-link-alt"></i></span></li><li>npm install hexo-theme-next</li><li>하면 기존것에 대충 잘 버무려짐</li></ol><h4 id="Hexo-Admin-을-사용하여-관리하기"><a href="#Hexo-Admin-을-사용하여-관리하기" class="headerlink" title="Hexo Admin 을 사용하여 관리하기"></a>Hexo Admin 을 사용하여 관리하기</h4><ol><li>npm install hexo-admin –save</li><li>hexo s 하여 서버올리고 url 뒤에 &#x2F;admin 붙여서 로그인한다.</li><li>_config.yml 파일에 아이디 비밀번호 등을 체크한다.</li></ol><p>참고:<br>별5<br><span class="exturl" data-url="aHR0cHM6Ly90YWV0YWV0YWUuZ2l0aHViLmlvLzIwMTYvMDkvMTgvaGV4b19naXRodWJfYmxvZy8=">https://taetaetae.github.io/2016/09/18/hexo_github_blog/<i class="fa fa-external-link-alt"></i></span><br>별2<br><span class="exturl" data-url="aHR0cHM6Ly9taW5zdy5naXRodWIuaW8vMjAyMS8wMS8xOC9IZXhvLSVFQiVCOCU5NCVFQiVBMSU5QyVFQSVCNyVCOC0lRUMlOEIlQUMlRUQlOEYlOTAlRUMlODYlOEMlRUMlODMlOUQlRUMlODglQTAlRUQlOTUlOTglRUElQjglQjAv">https://minsw.github.io/2021/01/18/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%AC%ED%8F%90%EC%86%8C%EC%83%9D%EC%88%A0%ED%95%98%EA%B8%B0/<i class="fa fa-external-link-alt"></i></span><br>별4<br><span class="exturl" data-url="aHR0cHM6Ly90ZWNod2VsbC53b29yaXRlY2guY29tL2Jsb2cvMjAyMS8wOC8wOC9IZXhvLSVFQiVCOCU5NCVFQiVBMSU5QyVFQSVCNyVCOC8=">https://techwell.wooritech.com/blog/2021/08/08/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
