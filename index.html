<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/exploreHA/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/exploreHA/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/exploreHA/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/exploreHA/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/exploreHA/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jspgmp.github.io","root":"/exploreHA/","images":"/exploreHA/images","scheme":"Gemini","darkmode":true,"version":"8.14.1","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/exploreHA/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/config.min.js"></script>

    <meta name="description" content="설명">
<meta property="og:type" content="website">
<meta property="og:title" content="블로그제목">
<meta property="og:url" content="https://jspgmp.github.io/exploreHA/index.html">
<meta property="og:site_name" content="블로그제목">
<meta property="og:description" content="설명">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="북극여우">
<meta property="article:tag" content="자바, 스위프트">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jspgmp.github.io/exploreHA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>블로그제목 - 두번째블로그</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/third-party/analytics/google-analytics.min.js"></script>






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/exploreHA/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/exploreHA/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">블로그제목</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">두번째블로그</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/exploreHA/" rel="section"><i class="fa fa-bell fa-fw"></i>Home</a></li><li class="menu-item menu-item-docs"><a href="/exploreHA/docs/" rel="section"><i class="fa fa-book fa-fw"></i>Docs</a></li><li class="menu-item menu-item-archives"><a href="/exploreHA/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">15</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">북극여우</p>
  <div class="site-description" itemprop="description">설명</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/exploreHA/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/08/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20Redis%20%EC%84%B8%EC%85%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/08/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20Redis%20%EC%84%B8%EC%85%98/" class="post-title-link" itemprop="url">스프링부트 Redis 세션설정으로 중복 로그인 방지</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-14 16:46:32" itemprop="dateCreated datePublished" datetime="2023-08-14T16:46:32+09:00">2023-08-14</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/08/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20Redis%20%EC%84%B8%EC%85%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/08/14/스프링부트 Redis 세션/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring Security의 SessionManagementConfigurer가 제공하는 sessionRegistry()는 일반적으로 인메모리 세션 관리를 사용합니다. 즉, 단일 JVM 인스턴스 내에서만 세션 정보를 추적하게 됩니다.</p>
<p>여러 인스턴스 또는 분산된 환경에서 애플리케이션을 실행하는 경우 (예: 클라우드 환경, 마이크로서비스 아키텍처, 로드 밸런서 뒤의 여러 서버 인스턴스) 이러한 인메모리 세션 관리 방식은 문제를 일으킬 수 있습니다. 왜냐하면 각 JVM 인스턴스는 자신만의 세션 정보를 가지고 있어서 다른 인스턴스의 세션 정보를 알지 못하기 때문입니다.</p>
<p>반면, SpringSessionBackedSessionRegistry는 Spring Session을 사용하며, Spring Session은 외부 저장소 (예: Redis, JDBC, Hazelcast 등)를 사용하여 세션 정보를 저장합니다. 이 방식을 사용하면 여러 애플리케이션 인스턴스 간에 세션 정보를 공유할 수 있습니다.</p>
<p>따라서:</p>
<p>단일 인스턴스 환경에서는 Spring Security의 기본 sessionRegistry()만으로도 충분합니다.<br>하지만 여러 인스턴스에서 세션 정보를 공유해야 하는 환경에서는 SpringSessionBackedSessionRegistry와 같은 방법을 사용하여 Spring Session을 활용해야 합니다.<br>이렇게 설정함으로써 여러 서버 인스턴스 간에 세션 정보를 일관되게 공유하면서 동시 로그인 제한과 같은 기능을 정상적으로 구현할 수 있습니다.</p>
<p>사전 Redis 세션 설정을 마치고 추가적으로 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FindByIndexNameSessionRepository sessionRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SpringSessionBackedSessionRegistry <span class="title function_">sessionRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringSessionBackedSessionRegistry</span>&lt;&gt;(<span class="built_in">this</span>.sessionRepository);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    .sessionManagement()</span><br><span class="line">        .maximumSessions(<span class="number">1</span>)</span><br><span class="line">        .maxSessionsPreventsLogin(<span class="literal">true</span>)</span><br><span class="line">        .sessionRegistry(sessionRegistry())</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>커스텀 로그인 핸들이 없어도 된다. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/06/30/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8aws%EC%85%8B%EC%97%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/06/30/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8aws%EC%85%8B%EC%97%85/" class="post-title-link" itemprop="url">프로젝트aws셋업</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-30 21:47:43" itemprop="dateCreated datePublished" datetime="2023-06-30T21:47:43+09:00">2023-06-30</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/06/30/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8aws%EC%85%8B%EC%97%85/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/06/30/프로젝트aws셋업/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="프론트-백엔드-프로젝트-aws로-서비스하기"><a href="#프론트-백엔드-프로젝트-aws로-서비스하기" class="headerlink" title="프론트+백엔드 프로젝트 aws로 서비스하기"></a>프론트+백엔드 프로젝트 aws로 서비스하기</h1><h2 id="1-프로젝트-소개"><a href="#1-프로젝트-소개" class="headerlink" title="1. 프로젝트 소개"></a>1. 프로젝트 소개</h2><p>학원 운영을 하며 여러가지 관리할것들이 쌓이다보니, 상당히 복잡해져 웹서비스로 준비하게 되었다. </p>
<h3 id="프론트엔드-DevExtreme-리액트-라이브러리"><a href="#프론트엔드-DevExtreme-리액트-라이브러리" class="headerlink" title="프론트엔드: DevExtreme 리액트 라이브러리"></a>프론트엔드: DevExtreme 리액트 라이브러리</h3><p>개인은 무료다.<br>DataGrid, Shceduler, 기본 template으로 다 했다.<br>jsp mvc에서는 화면을 전적으로 백엔드에서 통제를 하지만, 리액트에서는 별개로 돌아가기 때문에 강제로 로그인 이후 화면으로 진입한다면 리소스 제한만 했다.<br>Doc를 보면서 화면을 제작하다보니 가장 많은 시간이 들어갔고, 컴포넌트 안에 컴포넌트를 반복해서 집어넣다보니 상태관리나 변수 조절이 까다로웠다. </p>
<h3 id="백엔드-스프링부트"><a href="#백엔드-스프링부트" class="headerlink" title="백엔드: 스프링부트"></a>백엔드: 스프링부트</h3><p>JPA로 여러 엔티티를 모조리 관계를 맺었다.<br>useYn 과 레코드 삭제(cascade)까지 사용했다. cascade 설정 시 customId를 사용하면 생성시기가 늦어 삭제가 안되므로 cascade적용 엔티티는 기본 id생성규칙을 따랐다.<br>RDS로 설정했다가 비용이 많이나와서 ec2에 직접 mysql8을 설치해서 사용하는것으로 변경했다. 로컬 개발환경의 mysql과 ec2 의 것을 일치시키면 편하다.<br>스프링 시큐리티 로그인(jwt)을 적용했다. </p>
<h2 id="2-aws으로"><a href="#2-aws으로" class="headerlink" title="2. aws으로"></a>2. aws으로</h2><h3 id="인스턴스-설정"><a href="#인스턴스-설정" class="headerlink" title="인스턴스 설정"></a>인스턴스 설정</h3><p>처음 ami 고를 때 amazon linux 2023으로 했더니 mysql8설치가 귀찮아졌다. 빠르게 인스턴스 세팅을 다시 amazon linux 2로 하다가 인스턴스 유형을 x86 t2.micro에서 arm t4g.micro로 변경했다. 이유는 속도는 비슷하고 조금 더 싸다.<br>온디맨드 시간당 t2.micro : 0.0116USD, t4g.micro : 0.0084USD<br>프리티어는 날아가서 없다. </p>
<h4 id="보안그룹"><a href="#보안그룹" class="headerlink" title="보안그룹"></a>보안그룹</h4><p>처음에 인스턴스 생성 시 보안그룹을 만들거나 기존것을 고른다.<br>인바운드: http로 들어오니 80포트 모두에게<br>쉘로 붙어야 하니 22포트 내 ip만<br>로컬에서 DB 넣어야 하니 3306포트 내 ip만, 아웃바운드는 다 허용</p>
<h4 id="자바-설치"><a href="#자바-설치" class="headerlink" title="자바 설치"></a>자바 설치</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list <span class="strong">*java*</span> </span><br></pre></td></tr></table></figure>
<p>검색해서 원하는 것으로 설치한다.<br>나는 java-17-amazon-corretto-headless.aarch64<br>으로 설치했다. </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span> -version</span><br><span class="line"></span><br><span class="line"><span class="attribute">openjdk</span> version <span class="string">&quot;17.0.7&quot;</span> <span class="number">2023</span>-<span class="number">04</span>-<span class="number">18</span> LTS</span><br><span class="line"><span class="attribute">OpenJDK</span> Runtime Environment Corretto-<span class="number">17.0.7.7</span>.<span class="number">1</span> (build <span class="number">17</span>.<span class="number">0</span>.<span class="number">7</span>+<span class="number">7</span>-LTS)</span><br><span class="line"><span class="attribute">OpenJDK</span> <span class="number">64</span>-Bit Server VM Corretto-<span class="number">17.0.7.7</span>.<span class="number">1</span> (build <span class="number">17</span>.<span class="number">0</span>.<span class="number">7</span>+<span class="number">7</span>-LTS, mixed mode, sharing)</span><br></pre></td></tr></table></figure>
<p>잘 나오니 환경변수 설정은 패스한다. </p>
<h4 id="nginx-설치"><a href="#nginx-설치" class="headerlink" title="nginx 설치"></a>nginx 설치</h4><p>인스턴스로 http를 타고 들어오면 80포트로 들어온다.<br>리액트를 빌드해서 스프링부트에 넣고 다시 war로 감싸서 8080포트로 들어가야 하므로 리버스 프록시 설정을 해줄 nginx를 설치한다. </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br><span class="line">sudo vi <span class="regexp">/etc/</span>nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>80포트를 8080으로 물려주는 세팅을 한다. (###안 부분)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment">################################################</span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-For proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="comment">################################################</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="section">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">            <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>대개는 location 안쪽만 수정을 하면된다. </p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="params">system</span>ctl start nginx</span><br><span class="line">sudo <span class="params">system</span>ctl enable nginx</span><br></pre></td></tr></table></figure>
<p>시작하고 시작프로그램으로 등록한다. </p>
<h4 id="mysql8-설치-amazon-linux-2"><a href="#mysql8-설치-amazon-linux-2" class="headerlink" title="mysql8 설치 (amazon linux 2)"></a>mysql8 설치 (amazon linux 2)</h4><p>amazon linux 2023은 잘 안됐다. 그래서 인스턴트 다시 생성</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo amazon-linux-<span class="keyword">extras </span><span class="keyword">install </span>epel -y</span><br></pre></td></tr></table></figure>
<p>epel repo 설치</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install https:<span class="regexp">//</span>repo.mysql.com/mysql80-community-release-el7-<span class="number">5</span>.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>MySql Community Repo 설치(최신버전있는데 이걸로하는게 설치 잘됌)</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-community-<span class="keyword">server</span></span><br><span class="line">sudo yum install mysql-community-<span class="keyword">client</span></span><br></pre></td></tr></table></figure>
<p>둘째줄은 이미 설치됐다고 나왔다.<br>출처: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1ldmkudGVjaC9pbnN0YWxsLW15c3FsLTgtY2xpZW50LW9uLWFtYXpvbi1saW51eC0yLWFybS1hbmQteDg2XzY0Lw==">https://blog.mevi.tech/install-mysql-8-client-on-amazon-linux-2-arm-and-x86_64/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start <span class="symbol">mysqld@</span></span><br></pre></td></tr></table></figure>
<p>mysql을 실행한다. </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<p>mysql8은 초기비밀번호가 있단다. 찾으러간다.</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /var/<span class="keyword">log</span>/mysqld.<span class="keyword">log</span></span><br><span class="line"></span><br><span class="line"><span class="number">2023</span><span class="number">-06</span><span class="number">-30</span>T04:<span class="number">13</span>:<span class="number">52.839282</span>Z <span class="number">6</span> [Note] [MY<span class="number">-010454</span>] [<span class="keyword">Server</span>] A <span class="keyword">temporary</span> <span class="keyword">password</span> <span class="keyword">is</span> <span class="keyword">generated</span> <span class="keyword">for</span> root@localhost: <span class="number">13</span>KI1ddFdJ-(</span><br></pre></td></tr></table></figure>
<p>비밀번호는 13KI1ddFdJ-( 이다. </p>
<p>다시 mysql 에 로그인해서 root 계정 비밀번호를 바꾼다. </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;새비번&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>프로젝트에 쓸 DB를 만든다. </p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> ssbDB;</span><br></pre></td></tr></table></figure>

<p>프로젝트용 계정을 만들고 권한을 부여한다. </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;아이디&#x27;</span>@<span class="string">&#x27;접속위치(ip)&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;비번&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> ssbDB.* <span class="keyword">TO</span> <span class="string">&#x27;아이디&#x27;</span>@<span class="string">&#x27;접속위치(ip)&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>프로젝트에서 테스트하니 Public Key Retrieval is not allowed 발생.</p>
<p>방법1. url 에 allowPublicKeyRetrieval&#x3D;true 붙이기</p>
<p>방법2. 사용자 인증 플러그인 native_password로 바꾸기</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;User&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;비번&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>나는 방법 2로 했다. </p>
<h4 id="젠킨스-설치-패스"><a href="#젠킨스-설치-패스" class="headerlink" title="젠킨스 설치(패스)"></a>젠킨스 설치(패스)</h4><p>젠킨스 설치는 다른데도 많으니 생략한다.<br>리액트를 eirslett 라이브러리를 써서 프로젝트 빌드시<br>리액트빌드-&gt; resources&#x2F;static으로 파일 이동 -&gt; 스프링부트 빌드 -&gt; target에 war 생성 순으로 설정했다.<br>그러나 리액트 빌드 도중 메모리 부족으로 실패. </p>
<p>package.json에서 빌드 명령어 수정 </p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;<span class="keyword">build</span><span class="string">&quot;: &quot;</span><span class="keyword">set</span> NODE_OPTIONS=--max_old_space_size=<span class="number">4096</span>&amp;&amp;<span class="keyword">set</span> GENERATE_SOURCEMAP=<span class="literal">false</span>&amp;&amp;react-scripts <span class="keyword">build</span><span class="string">&quot;,</span></span><br></pre></td></tr></table></figure>
<p>스왑 메모리 설정</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo fallocate -l 2G /swapfile</span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line">sudo swapon --show</span><br><span class="line">sudo nano /etc/fstab</span><br><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure>
<p>결과: 계속 실패(돈많으면 가능…)</p>
<p>젠킨스 사용 보류 </p>
<h4 id="war-시작-파일-만들기-옵션"><a href="#war-시작-파일-만들기-옵션" class="headerlink" title="war 시작 파일 만들기(옵션)"></a>war 시작 파일 만들기(옵션)</h4><p>파일 위치는 변경 후 사용해야한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WAR 파일 경로</span></span><br><span class="line">WAR_FILE=<span class="string">&quot;./dscheduler-0.0.1-SNAPSHOT.war&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 포트 설정</span></span><br><span class="line">PORT=8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># Java 실행 명령어</span></span><br><span class="line">JAVA_CMD=<span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JVM 옵션</span></span><br><span class="line">JAVA_OPTS=<span class="string">&quot;-Xmx512m -Xms256m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 로그 폴더 경로</span></span><br><span class="line">LOG_FOLDER=<span class="string">&quot;./logs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 백그라운드에서 WAR 파일 실행</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Starting the application...&quot;</span></span><br><span class="line">  LOG_FILE=<span class="string">&quot;<span class="variable">$LOG_FOLDER</span>/ssbScheduler-<span class="subst">$(date +&#x27;%Y-%m-%d&#x27;)</span>.log&quot;</span></span><br><span class="line">  <span class="built_in">nohup</span> <span class="variable">$JAVA_CMD</span> <span class="variable">$JAVA_OPTS</span> -jar <span class="variable">$WAR_FILE</span> --server.port=<span class="variable">$PORT</span> &gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span> 2&gt;&amp;1 &amp;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Application started. Logs are being saved to: <span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행 중인 프로세스 종료</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Stopping the application...&quot;</span></span><br><span class="line">  PID=$(pgrep -f <span class="variable">$WAR_FILE</span>)</span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$PID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> <span class="variable">$PID</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Application stopped.&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Application is not running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 명령어 파라미터에 따라 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> &#123;start|stop&#125;&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h4 id="탄력적-IP-설정-및-연결"><a href="#탄력적-IP-설정-및-연결" class="headerlink" title="탄력적 IP 설정 및 연결"></a>탄력적 IP 설정 및 연결</h4><p>ec2 &gt; 탄력적IP -&gt; 주소할당-&gt; 주소연결(인스턴스로)</p>
<p>이렇게 인스턴스 세팅은 끝이다. 다음은 aws 세팅이다. </p>
<h3 id="aws-설정"><a href="#aws-설정" class="headerlink" title="aws 설정"></a>aws 설정</h3><h4 id="도메인-route53"><a href="#도메인-route53" class="headerlink" title="도메인(route53)"></a>도메인(route53)</h4><p>aws 콘솔&gt;Route53&gt;등록된 도메인&gt;도메인 등록<br>도메인 골라서 결제(꽤비쌈)<br>route53에서 도메인을 구매했더니 대기중인 요청에 한 10분정도 있다가 호스팅영역에 자동으로 추가되고 네임서버도 자동으로 등록이 되어있었다. </p>
<p>호스팅영역에서 ip를 연결한다. https인증서를 쓸려면 로드밸런서를 연결한다.<br>나는 1인 유저기때문에 바로 ip에 연결했다.</p>
<p>호스팅영역-&gt;레코드 생성. 아래와 같이 작성</p>
<p>레코드 이름: 원하는 이름<br>레코드 유형: A<br>값: 연결할 ip 입력.<br>TTL: 300<br>라우팅 정책: 지리적위치(한국에서만)<br>위치: 한국<br>레코드ID: 내맘대로</p>
<h4 id="RDS-적용취소"><a href="#RDS-적용취소" class="headerlink" title="RDS(적용취소)"></a>RDS(적용취소)</h4><p>db.t3.small 싱글 인스턴스 가격 0.063USD&#x2F;h 이 나와서 인스턴스 내 db를 설치해서 사용하기로 노선변경<br>가장 싼 db.t4g.micro 를 사용하면 0.025USD&#x2F;h 한달에 3만원가량<br>-&gt; 이건 무려 프리티어지만 나는 프리하지 않다..<br>그 외 저장 비용등은 낮아서 생략한다.<br><img src="/exploreHA/images/image.png"></p>
<h4 id="SPOT인스턴스-적용취소"><a href="#SPOT인스턴스-적용취소" class="headerlink" title="SPOT인스턴스(적용취소)"></a>SPOT인스턴스(적용취소)</h4><p>RDS -&gt; 로컬DB 사용으로 패스<br>RDS를 사용한다면 SPOT으로 변경하고 때때로 서비스 불량이 있을 수 있지만<br>가격이 낮아져 t4g.small을 사용할수도 있을 것 같다.<br>그러면 메모리가 2기가로 높아지고 속도가 올라가 리액트 빌드가 가능해지고<br>젠킨스를 사용할 수 있게 될것으로 예상<br>비용은 4만원&#x2F;월 정도 예상</p>
<p>접속 순서 정리:<br>브라우저에서 설정한 도메인 입력<br>탄력ip로 연결<br>인스턴스 보안그룹 통과<br>nginx가 8080으로 연결<br>스프링부트에서 로컬 db 접근<br>스프링부트 내 index.html 으로 안내</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98-%EA%B5%AC%EB%8F%99%EC%88%9C%EC%84%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98-%EA%B5%AC%EB%8F%99%EC%88%9C%EC%84%9C/" class="post-title-link" itemprop="url">스프링부트 배치 구동순서</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-14 12:04:02" itemprop="dateCreated datePublished" datetime="2023-04-14T12:04:02+09:00">2023-04-14</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/14/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98-%EA%B5%AC%EB%8F%99%EC%88%9C%EC%84%9C/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/14/스프링부트-배치-구동순서/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>스프링 부트 배치는 대량의 데이터를 처리하는데 유용한 프레임워크입니다. 이를 사용하면 일괄 처리(batch processing) 작업을 효율적으로 수행할 수 있습니다. 스프링 부트 배치는 다양한 구성 요소로 구성되며, 이러한 구성 요소는 특정 순서로 구동되어야 합니다. 이번 포스팅에서는 스프링 부트 배치 구동 순서에 대해 자세히 알아보겠습니다.</p>
<p>JobRepository<br>스프링 부트 배치는 먼저 JobRepository를 생성합니다. 이는 배치 작업을 수행하는 동안 상태 정보를 저장하는 데 사용됩니다. JobRepository는 데이터베이스를 기반으로 작동하며, 스프링 부트 배치는 사용자가 지정한 데이터베이스를 기본적으로 사용합니다.</p>
<p>JobLauncher<br>JobRepository가 생성되면, 다음으로 JobLauncher가 생성됩니다. JobLauncher는 JobRepository를 사용하여 배치 작업을 시작합니다. 이를 위해 JobLauncher는 Job과 JobParameters를 매개변수로 받아들입니다.</p>
<p>Job<br>JobLauncher가 생성되면 Job도 생성됩니다. Job은 일괄 처리 작업의 실행 단위입니다. Job은 하나 이상의 Step으로 구성됩니다.</p>
<p>Step<br>Step은 일괄 처리 작업의 개별 단계를 정의합니다. Step은 Reader, Processor, Writer로 구성됩니다. Reader는 데이터 소스에서 데이터를 읽어들이고, Processor는 데이터를 가공하고, Writer는 가공된 데이터를 저장합니다.</p>
<p>ItemReader<br>ItemReader는 Step에서 사용되며, 데이터 소스에서 데이터를 읽어들입니다.</p>
<p>ItemProcessor<br>ItemProcessor는 Step에서 사용되며, 읽어들인 데이터를 가공합니다.</p>
<p>ItemWriter<br>ItemWriter는 Step에서 사용되며, 가공된 데이터를 저장합니다.</p>
<p>ExecutionContext<br>ExecutionContext는 Step의 상태 정보를 저장하는 데 사용됩니다. 이를 사용하여 다음 번 실행 시점에 이전 실행 결과를 기반으로 작업을 수행할 수 있습니다.</p>
<p>JobExecution<br>JobExecution은 Job의 실행 상태 정보를 저장합니다. JobExecution은 JobRepository에 저장됩니다.</p>
<p>JobInstance<br>JobInstance는 Job의 인스턴스를 나타냅니다. 즉, 동일한 Job을 여러 번 실행할 경우, 각 실행마다 별도의 JobInstance가 생성됩니다.</p>
<p>JobParameters<br>JobParameters는 Job을 실행할 때 전달되는 매개변수입니다. 예를 들어, Job을 실행할 때 사용할 데이터베이스 연결 정보나 파일 경로 등을 전달할 수 있습니다.</p>
<p>이러한 구성 요소는 스프링 부트 배치를 구성하는 데 필요한 기본적인 요소입니다. 스프링 부트 배치를 사용할 때에는 이러한 구성 요소들이 어떻게 상호작용하는지 이해하는 것이 중요합니다. 일괄 처리 작업을 실행할 때, 스프링 부트 배치는 JobRepository를 사용하여 JobExecution과 StepExecution의 상태 정보를 저장하고, ExecutionContext를 사용하여 상태 정보를 공유합니다. 또한 JobLauncher를 사용하여 Job을 시작하고, Job은 하나 이상의 Step으로 구성되며, Step은 ItemReader, ItemProcessor, ItemWriter로 구성됩니다.</p>
<p>각 구성 요소들의 역할을 이해하면 스프링 부트 배치를 사용하여 일괄 처리 작업을 효율적으로 구현할 수 있습니다. 또한 스프링 부트 배치에서는 다양한 기능들을 제공하므로, 필요에 따라 설정을 변경하여 개인적인 요구사항에 맞게 사용할 수 있습니다. 예를 들어, Job의 실행 주기를 설정하거나, Step의 실행 순서를 변경하는 등의 설정을 변경할 수 있습니다.</p>
<p>스프링 부트 배치는 대규모 데이터 처리를 위한 강력한 프레임워크입니다. 이를 사용하여 데이터 처리 작업을 효율적으로 수행할 수 있으며, 이를 위해 필요한 구성 요소들을 제공합니다. 스프링 부트 배치의 구동 순서를 이해하고, 필요한 설정을 변경하여 개인적인 요구사항에 맞게 사용하면, 더욱 효율적으로 일괄 처리 작업을 수행할 수 있습니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/" class="post-title-link" itemprop="url">스프링부트</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 10:23:17" itemprop="dateCreated datePublished" datetime="2023-04-13T10:23:17+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/스프링부트/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="스프링부트를-쓰는-이유"><a href="#스프링부트를-쓰는-이유" class="headerlink" title="스프링부트를 쓰는 이유"></a>스프링부트를 쓰는 이유</h2><p>스프링부트는 스프링 프레임워크를 기반으로 한 자바 웹 어플리케이션을 보다 쉽게 개발하고 운영하기 위해 만들어졌습니다. 다음과 같은 이유로 스프링부트를 쓰는 것이 유용합니다.</p>
<h4 id="1-빠른-개발"><a href="#1-빠른-개발" class="headerlink" title="1. 빠른 개발"></a>1. 빠른 개발</h4><p>스프링부트는 설정이 간단하고, 빠른 애플리케이션 개발을 지원합니다. 개발자가 직접 설정을 할 필요 없이, 스프링부트의 자동설정을 이용하여 필요한 의존성을 추가하고 설정을 적용할 수 있습니다.</p>
<h4 id="2-간편한-배포"><a href="#2-간편한-배포" class="headerlink" title="2. 간편한 배포"></a>2. 간편한 배포</h4><p>스프링부트는 내장된 서버(Tomcat, Jetty 등)를 이용하여 애플리케이션을 실행할 수 있습니다. 이는 개발자가 별도의 외부 서버를 구축하지 않아도 되며, 배포가 간단해집니다.</p>
<h4 id="3-통합된-모니터링"><a href="#3-통합된-모니터링" class="headerlink" title="3. 통합된 모니터링"></a>3. 통합된 모니터링</h4><p>스프링부트는 애플리케이션의 상태를 모니터링할 수 있는 엔드포인트(Actuator)를 제공합니다. 이 엔드포인트를 이용하여 메모리 사용량, 쓰레드 개수, JDBC 연결 정보 등을 확인할 수 있습니다.</p>
<h4 id="4-간단한-테스트-환경-구축"><a href="#4-간단한-테스트-환경-구축" class="headerlink" title="4. 간단한 테스트 환경 구축"></a>4. 간단한 테스트 환경 구축</h4><p>스프링부트는 내장된 서버와 자동설정 기능을 이용하여 간단한 테스트 환경을 구축할 수 있습니다. 개발자는 별도의 서버나 DB 설정 없이 애플리케이션을 바로 테스트할 수 있습니다.</p>
<h4 id="5-다양한-환경-지원"><a href="#5-다양한-환경-지원" class="headerlink" title="5. 다양한 환경 지원"></a>5. 다양한 환경 지원</h4><p>스프링부트는 다양한 환경에서 애플리케이션을 실행할 수 있습니다. 클라우드 서비스(AWS, GCP 등)를 비롯하여, 스프링클라우드와 통합하여 클라우드에서 애플리케이션을 실행할 수 있습니다.</p>
<h4 id="6-자동설정-기능"><a href="#6-자동설정-기능" class="headerlink" title="6. 자동설정 기능"></a>6. 자동설정 기능</h4><p>스프링부트는 자동설정 기능을 제공하여 설정을 간단하게 처리할 수 있습니다. 예를 들어, JPA를 이용하여 DB 작업을 수행할 경우, 스프링부트는 자동으로 EntityManager를 생성하고, 트랜잭션 처리를 해줍니다.</p>
<h4 id="7-개발-환경-구축의-용이성"><a href="#7-개발-환경-구축의-용이성" class="headerlink" title="7. 개발 환경 구축의 용이성"></a>7. 개발 환경 구축의 용이성</h4><p>스프링부트는 개발환경을 구축하는데 있어 많은 도움을 줍니다. Maven, Gradle 등의 빌드 툴을 이용하여 의존성을 관리하고, JAR, WAR 파일을 쉽게 빌드할 수 있습니다. 또한 스프링부트는 스프링 이니셜라이저를 제공하여, 초기 설정을 쉽게 생성할 수 있습니다.</p>
<h4 id="8-관련-커뮤니티"><a href="#8-관련-커뮤니티" class="headerlink" title="8. 관련 커뮤니티"></a>8. 관련 커뮤니티</h4><p>스프링부트는 스프링 프레임워크를 기반으로 하기 때문에, 스프링 프레임워크와 관련된 다양한 커뮤니티를 활용할 수 있습니다. 또한 스프링부트는 다양한 라이브러리와 프레임워크와 연동이 가능합니다.</p>
<h4 id="9-성능"><a href="#9-성능" class="headerlink" title="9. 성능"></a>9. 성능</h4><p>스프링부트는 내장된 서버를 이용하므로, 서버를 구축하지 않아도 되며, 클라우드에서 애플리케이션을 실행할 수 있어, 성능면에서 우수한 결과를 보입니다. 또한, 스프링부트는 내부적으로 캐싱을 적용하여 성능을 향상시킬 수 있습니다.</p>
<h4 id="10-다양한-기능"><a href="#10-다양한-기능" class="headerlink" title="10. 다양한 기능"></a>10. 다양한 기능</h4><p>스프링부트는 다양한 기능을 제공합니다. AOP, 캐싱, 보안 등 다양한 모듈을 이용하여 애플리케이션을 구성할 수 있습니다. 또한, 스프링부트는 스프링데이터를 이용하여 다양한 데이터베이스를 지원하며, 스프링 시큐리티를 이용하여 보안기능을 구현할 수 있습니다.</p>
<p>스프링부트는 스프링 프레임워크를 보다 쉽게 사용할 수 있도록 만들어졌습니다. 스프링부트를 이용하면 애플리케이션을 빠르게 개발하고, 배포할 수 있으며, 모니터링과 테스트를 간편하게 수행할 수 있습니다. 또한, 다양한 커뮤니티와 라이브러리를 활용하여 애플리케이션을 보다 높은 수준으로 구현할 수 있습니다. 따라서, 스프링부트는 자바 개발자에게 권장되는 프레임워크 중 하나입니다.</p>
<h2 id="스프링부트는-왜-생겨났을까"><a href="#스프링부트는-왜-생겨났을까" class="headerlink" title="스프링부트는 왜 생겨났을까?"></a>스프링부트는 왜 생겨났을까?</h2><p>스프링부트는 스프링 프레임워크를 기반으로 한 자바 웹 어플리케이션을 보다 쉽게 개발하고 운영하기 위해 만들어졌습니다. 이전에는 스프링 프레임워크를 이용한 개발 시 많은 설정과 라이브러리가 필요했고, 이를 일일이 구성하는 것이 어려웠습니다. 이러한 문제를 해결하기 위해 스프링부트는 자동설정과 스타터(dependency management)를 제공하여 개발자가 불필요한 설정 및 의존성 관리에 신경쓰지 않고, 개발에 집중할 수 있도록 도와줍니다.</p>
<p>스프링부트의 개발 목적은 다음과 같습니다.</p>
<ol>
<li>개발자 생산성 향상<ul>
<li>스프링부트는 자동설정, 스타터, CLI(Command Line Interface) 등을 제공하여 개발자가 빠르게 개발할 수 있도록 돕습니다.</li>
</ul>
</li>
<li>설정 간소화<ul>
<li>스프링부트는 설정 파일의 크기를 줄이고, 불필요한 설정을 자동으로 제거하여 개발자가 설정 관리를 쉽게 할 수 있도록 돕습니다.</li>
</ul>
</li>
<li>내장 서버 제공<ul>
<li>스프링부트는 내장된 서버를 제공하여 개발자가 별도의 서버를 구축하지 않아도 애플리케이션을 실행할 수 있습니다.</li>
</ul>
</li>
<li>확장 가능성<ul>
<li>스프링부트는 스프링 프레임워크와 연동하여 스프링의 다양한 모듈과 기능을 활용할 수 있습니다.</li>
</ul>
</li>
<li>운영 및 배포의 용이성<ul>
<li>스프링부트는 애플리케이션의 설정과 라이브러리 의존성을 자동으로 관리하여, 배포 시 일관된 환경을 제공합니다. 또한, 애플리케이션의 상태를 모니터링할 수 있는 엔드포인트를 제공하여, 운영 및 모니터링을 용이하게 합니다.</li>
</ul>
</li>
</ol>
<h2 id="스프링-DI-Dependency-Injection"><a href="#스프링-DI-Dependency-Injection" class="headerlink" title="스프링 DI (Dependency Injection)"></a>스프링 DI (Dependency Injection)</h2><p>DI는 Dependency Injection의 약자로, 객체간의 의존성을 느슨하게 만들기 위한 디자인 패턴 중 하나입니다. 객체가 직접 의존하는 객체를 생성하거나, 컨테이너가 직접 생성하여 의존성을 주입하는 방식으로 작동합니다.</p>
<p>스프링에서는 DI를 위해 <code>@Autowired</code> 어노테이션을 제공합니다. <code>@Autowired</code> 어노테이션을 사용하여 의존성 주입을 자동화할 수 있습니다. 이를 통해 객체 간의 결합도를 낮추고, 유지보수 및 확장성을 높일 수 있습니다.</p>
<h3 id="객체-주입-방식의-종류와-특징"><a href="#객체-주입-방식의-종류와-특징" class="headerlink" title="객체 주입 방식의 종류와 특징"></a>객체 주입 방식의 종류와 특징</h3><p>DI (Dependency Injection)는 객체 간의 의존성을 낮추기 위한 디자인 패턴으로, 스프링에서는 다양한 객체 주입 방식을 제공합니다. 여러 객체 주입 방식의 특징과 차이점을 살펴보겠습니다.</p>
<h4 id="1-생성자-주입-Constructor-Injection"><a href="#1-생성자-주입-Constructor-Injection" class="headerlink" title="1. 생성자 주입(Constructor Injection)"></a>1. 생성자 주입(Constructor Injection)</h4><p>생성자 주입은 객체를 생성할 때, 생성자를 통해 의존성을 주입하는 방식입니다. 생성자 주입 방식은 다음과 같은 특징이 있습니다.</p>
<ul>
<li>불변성(Immutability): 생성자를 통해 한 번 주입되면 의존성을 변경할 수 없습니다.</li>
<li>필수적인 의존성 주입: 모든 의존성이 생성자에 주입되어야 하기 때문에, 필수적인 의존성이 존재할 경우 사용합니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Setter-주입-Setter-Injection"><a href="#2-Setter-주입-Setter-Injection" class="headerlink" title="2. Setter 주입(Setter Injection)"></a>2. Setter 주입(Setter Injection)</h4><p>Setter 주입은 Setter 메서드를 통해 의존성을 주입하는 방식입니다. Setter 주입 방식은 다음과 같은 특징이 있습니다.</p>
<ul>
<li>유연성: Setter 메서드를 통해 의존성을 변경할 수 있습니다.</li>
<li>선택적인 의존성 주입: Setter 메서드가 존재하면 해당 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-필드-주입-Field-Injection"><a href="#3-필드-주입-Field-Injection" class="headerlink" title="3. 필드 주입(Field Injection)"></a>3. 필드 주입(Field Injection)</h4><p>필드 주입은 필드를 직접 주입하는 방식입니다. 필드 주입 방식은 다음과 같은 특징이 있습니다.</p>
<ul>
<li>코드 가독성 저하: 필드를 직접 주입하면, 해당 필드가 어떤 의존성을 가지는지 명확하지 않습니다.</li>
<li>유연성: 필드를 직접 주입하면, 의존성을 변경하기 쉽습니다.</li>
<li>적극적인 의존성 주입: 모든 필드에 대해 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-메서드-주입-Method-Injection"><a href="#4-메서드-주입-Method-Injection" class="headerlink" title="4. 메서드 주입(Method Injection)"></a>4. 메서드 주입(Method Injection)</h4><p>메서드 주입은 일반적인 메서드를 통해 의존성을 주입하는 방식입니다. 메서드 주입 방식은 다음과 같은 특징이 있습니다.</p>
<ul>
<li>특정 메서드를 통한 의존성 주입: 일반적인 메서드를 통해 의존성을 주입하기 때문에, 특정 메서드에 대해 유연하게 처리할 수 있습니다.</li>
<li>선택적인 의존성 주입: 의존성이 존재하는 메서드에 대해서만 의존성을 주입할 수 있습니다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Setter 주입과 메서드 주입(Method Injection)은 서로 비슷한 방법으로 의존성을 주입하는 방식이지만, 몇 가지 차이점이 있습니다.</li>
</ul>
<p>Setter 주입은 객체 생성 후, Setter 메서드를 통해 의존성을 주입하는 방식입니다. 이 방식은 의존성이 변경될 가능성이 있는 경우, Setter 메서드를 통해 의존성을 변경할 수 있는 장점이 있습니다.</p>
<p>메서드 주입은 생성자나 Setter 메서드가 아닌, 클래스 내부의 일반적인 메서드를 통해 의존성을 주입하는 방식입니다. 이 방식은 객체 생성 시점에 의존성이 결정되지 않아도 되는 장점이 있으며, Setter 메서드와 달리 메서드 이름에 제약이 없는 유연한 방식입니다.</p>
<p>즉, Setter 주입과 메서드 주입은 서로 다른 방식의 의존성 주입 방법입니다. Setter 주입은 Setter 메서드를 이용하여 의존성을 주입하고, 메서드 주입은 생성자나 Setter 메서드 이외의 일반적인 메서드를 이용하여 의존성을 주입합니다.</p>
<h3 id="객체-주입-방식-선택-시-고려해야-할-사항"><a href="#객체-주입-방식-선택-시-고려해야-할-사항" class="headerlink" title="객체 주입 방식 선택 시 고려해야 할 사항"></a>객체 주입 방식 선택 시 고려해야 할 사항</h3><p>객체 주입 방식을 선택할 때 고려해야 할 사항은 다음과 같습니다.</p>
<ol>
<li><p>의존성의 필수&#x2F;선택 여부: 생성자 주입 방식은 모든 의존성을 필수적으로 주입해야 하기 때문에, 필수적인 의존성이 존재하는 경우에 사용됩니다. 반면에 Setter 주입 방식은 선택적인 의존성이 존재하는 경우에 사용됩니다.</p>
</li>
<li><p>객체의 불변성: 생성자 주입 방식은 의존성이 주입된 이후에는 의존성을 변경할 수 없습니다. 따라서 불변성이 필요한 객체에는 생성자 주입 방식이 적합합니다.</p>
</li>
<li><p>유연성: Setter 주입 방식은 Setter 메서드를 통해 의존성을 변경할 수 있기 때문에, 의존성 변경이 빈번하게 발생하는 경우에 적합합니다.</p>
</li>
<li><p>코드 가독성: 필드 주입 방식은 필드를 직접 주입하기 때문에, 코드 가독성이 저하될 수 있습니다. 따라서 코드 가독성이 중요한 경우에는 생성자 주입 방식이나 Setter 주입 방식을 사용하는 것이 좋습니다.</p>
</li>
<li><p>특정 메서드를 통한 의존성 주입: 메서드 주입 방식은 특정 메서드를 통해 의존성을 주입하기 때문에, 특정 메서드에 대해 유연하게 처리할 수 있습니다.</p>
</li>
</ol>
<h2 id="스프링-IOC-Inversion-of-Control"><a href="#스프링-IOC-Inversion-of-Control" class="headerlink" title="스프링 IOC (Inversion of Control)"></a>스프링 IOC (Inversion of Control)</h2><p>스프링의 핵심 컨테이너인 ApplicationContext는 Inversion of Control(IoC)을 구현한 것입니다. IoC는 객체 지향 프로그래밍에서 발생하는 의존성 관리 문제를 해결하기 위해 등장한 개념으로, 객체 간의 의존성을 자동으로 연결해주는 프로그래밍 방식입니다.</p>
<p>스프링의 IoC는 객체의 생성, 소멸 등의 라이프사이클을 관리하며, 객체 간의 의존성을 관리하는 데에 중점을 둡니다. IoC는 객체 간의 의존성을 자동으로 연결해주는 역할을 합니다.</p>
<p>스프링의 IoC는 객체를 생성하는 시점과 의존성을 주입하는 시점을 분리합니다. 이를 통해 객체의 라이프사이클을 유연하게 관리할 수 있습니다. 스프링의 IoC는 객체 간의 의존성을 자동으로 주입해주는데, 이를 의존성 주입(Dependency Injection, DI)이라고 합니다.</p>
<p>스프링의 IoC는 빈(Bean)이라는 단위로 객체를 관리합니다. 빈은 ApplicationContext에 등록되어 있으며, 다른 빈에서 의존성 주입을 받을 수 있습니다. 빈은 XML 설정 파일이나 어노테이션을 이용하여 등록할 수 있습니다.</p>
<p>스프링의 IoC는 다양한 방식으로 의존성 주입을 처리합니다. 주요한 의존성 주입 방식으로는 생성자 주입(Constructor Injection), Setter 주입(Setter Injection), 필드 주입(Field Injection) 등이 있습니다. 이들은 각각 객체 생성 시점에 의존성을 주입하는 방식이 다르며, 상황에 따라 선택해서 사용할 수 있습니다.</p>
<p>스프링의 IoC는 객체의 생성과 소멸, 의존성 주입 등을 자동으로 처리해주므로, 객체 간의 의존성 관리 문제를 해결할 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다.</p>
<h2 id="스프링-AOP"><a href="#스프링-AOP" class="headerlink" title="스프링 AOP"></a>스프링 AOP</h2><p>AOP(Aspect-Oriented Programming)는 객체 지향 프로그래밍의 한계를 보완하기 위해 등장한 프로그래밍 패러다임입니다. AOP는 애플리케이션의 핵심 로직에서 발생하는 부가적인 작업들을 모듈화하여 코드의 재사용성과 유지보수성을 높여줍니다.</p>
<p>스프링 AOP는 스프링 프레임워크에서 제공하는 AOP 구현체입니다. 스프링 AOP는 프록시 패턴을 이용하여 메서드 실행 전&#x2F;후 등 특정 시점에 부가적인 로직을 수행할 수 있습니다.</p>
<p>스프링 AOP의 주요 구성 요소는 다음과 같습니다.</p>
<ol>
<li>Pointcut</li>
</ol>
<ul>
<li>Advice가 적용될 메서드를 지정하는 것을 의미합니다.</li>
</ul>
<ol start="2">
<li>Advice</li>
</ol>
<ul>
<li>메서드 실행 전&#x2F;후 등 특정 시점에서 수행할 로직을 정의합니다.</li>
</ul>
<ol start="3">
<li>Joinpoint</li>
</ol>
<ul>
<li>Advice가 적용될 수 있는 위치를 의미합니다. 메서드 호출, 예외 발생 등이 Joinpoint에 해당합니다.</li>
</ul>
<ol start="4">
<li>Aspect</li>
</ol>
<ul>
<li>Pointcut과 Advice의 결합체를 의미합니다.</li>
</ul>
<ol start="5">
<li>Target</li>
</ol>
<ul>
<li>AOP가 적용되는 대상 객체를 의미합니다.</li>
</ul>
<p>스프링 AOP는 다양한 Advice를 지원합니다.</p>
<ol>
<li>Before</li>
</ol>
<ul>
<li>메서드 실행 전에 수행할 로직을 정의합니다.</li>
</ul>
<ol start="2">
<li>After returning</li>
</ol>
<ul>
<li>메서드 실행 후 리턴 값이 존재할 경우 수행할 로직을 정의합니다.</li>
</ul>
<ol start="3">
<li>After throwing</li>
</ol>
<ul>
<li>메서드 실행 중 예외가 발생한 경우 수행할 로직을 정의합니다.</li>
</ul>
<ol start="4">
<li>After</li>
</ol>
<ul>
<li>메서드 실행 후 수행할 로직을 정의합니다.</li>
</ul>
<ol start="5">
<li>Around</li>
</ol>
<ul>
<li>메서드 실행 전&#x2F;후 등 모든 시점에서 수행할 로직을 정의합니다.</li>
</ul>
<p>스프링 AOP는 자바의 Proxy 클래스를 이용하여 프록시 객체를 생성합니다. 이를 통해 타깃 객체의 메서드를 호출하기 전&#x2F;후에 부가적인 로직을 수행할 수 있습니다. 또한, AOP를 적용할 때 XML 설정 파일이나 어노테이션을 이용하여 간편하게 설정할 수 있습니다.</p>
<p>스프링 AOP를 사용하면 애플리케이션의 핵심 로직과 부가적인 로직을 분리하여 구현할 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있으며, 특히 로깅, 트랜잭션, 보안 등과 같은 공통적인 작업을 간편하게 처리할 수 있습니다.</p>
<h2 id="스프링-ORM-Object-Relational-Mapping"><a href="#스프링-ORM-Object-Relational-Mapping" class="headerlink" title="스프링 ORM (Object-Relational Mapping)"></a>스프링 ORM (Object-Relational Mapping)</h2><p>ORM은 Object-Relational Mapping의 약자로, 객체와 관계형 데이터베이스 간의 매핑을 자동화하는 기술입니다. 스프링에서는 JPA(Java Persistence API)를 이용하여 ORM을 구현합니다.</p>
<p>스프링에서 ORM을 이용하면 객체지향적인 방식으로 데이터를 다룰 수 있습니다. 또한, ORM을 이용하면 SQL을 직접 작성하는 것보다 더 간편하게 데이터를 다룰 수 있습니다. 스프링에서는 Hibernate, MyBatis 등 다양한 ORM 프레임워크를 지원합니다.</p>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>Hibernate는 자바 언어를 위한 ORM(Object-Relational Mapping) 프레임워크입니다. ORM은 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리하는 기술입니다. 이를 통해 SQL 쿼리를 직접 작성하지 않아도 데이터베이스와 상호작용할 수 있습니다.</p>
<p>Hibernate는 객체와 데이터베이스 간의 매핑을 위해 XML 또는 어노테이션을 사용할 수 있습니다. Hibernate는 객체를 데이터베이스 테이블에 매핑하는 방식으로 동작합니다. 이를 위해 개발자는 데이터베이스 스키마와 매핑되는 Java 클래스를 작성하고, Hibernate 설정 파일을 작성하여 데이터베이스 연결 정보를 설정합니다.</p>
<p>Hibernate는 자바 Persistence API(JPA)를 구현하는 ORM 프레임워크입니다. JPA는 Java에서 ORM을 구현하기 위한 표준 인터페이스입니다. Hibernate는 JPA의 구현체 중 하나로, JPA에서 정의한 인터페이스를 구현하여 ORM을 제공합니다.</p>
<p>Hibernate는 데이터베이스와의 상호작용을 위해 Session과 Transaction 개념을 사용합니다. Session은 데이터베이스와의 세션을 의미하며, 데이터베이스 연결과 동일한 개념입니다. Transaction은 데이터베이스에서 수행되는 일련의 작업을 의미하며, 일반적으로 Session 내에서 실행됩니다.</p>
<p>Hibernate의 주요 기능으로는 다음과 같은 것들이 있습니다.</p>
<p>객체와 데이터베이스 간의 매핑 처리<br>객체와 데이터베이스 간의 관계 처리<br>객체와 데이터베이스 간의 쿼리 처리<br>객체와 데이터베이스 간의 트랜잭션 처리<br>Hibernate는 자바에서 ORM을 구현하는 대표적인 프레임워크 중 하나입니다. JPA를 구현한 ORM 프레임워크 중에서도 가장 널리 사용되는 프레임워크 중 하나이며, 대규모 애플리케이션에서도 안정적으로 사용됩니다.</p>
<h4 id="MyBatis-와-Hibernate"><a href="#MyBatis-와-Hibernate" class="headerlink" title="MyBatis 와 Hibernate"></a>MyBatis 와 Hibernate</h4><p>MyBatis와 Hibernate은 모두 자바에서 사용되는 ORM 프레임워크입니다. 하지만, MyBatis는 Hibernate과는 다른 방식으로 동작합니다.</p>
<p>MyBatis는 SQL 매핑 기반의 ORM 프레임워크로, 개발자가 직접 SQL 쿼리를 작성하고, 데이터베이스와 상호작용할 수 있는 방식으로 동작합니다. MyBatis는 SQL 매핑 파일과 Java 인터페이스를 이용하여 데이터베이스와의 상호작용을 처리합니다. 이에 비해 Hibernate는 객체와 데이터베이스 간의 매핑을 처리하며, SQL 쿼리를 자동으로 생성합니다.</p>
<p>MyBatis는 JDBC를 이용하여 데이터베이스와 상호작용하며, SQL 쿼리를 직접 작성할 수 있습니다. 반면, Hibernate는 JDBC보다 더 높은 추상화 수준을 제공하며, 객체와 데이터베이스 간의 매핑을 자동으로 처리합니다.</p>
<p>따라서, MyBatis는 Hibernate과는 다른 방식으로 동작합니다. MyBatis에서는 Hibernate과 같은 ORM 프레임워크에서 제공하는 객체와 데이터베이스 간의 매핑 기능이 제한적이며, 대신 SQL 쿼리를 직접 작성하여 데이터베이스와 상호작용하는 방식으로 동작합니다.</p>
<h2 id="스프링-MVC-life-cycle"><a href="#스프링-MVC-life-cycle" class="headerlink" title="스프링 MVC life cycle"></a>스프링 MVC life cycle</h2><p>스프링 MVC의 라이프사이클은 크게 다음과 같은 단계로 구성됩니다.</p>
<p>요청 처리 과정 시작</p>
<p>HandlerMapping을 통한 핸들러 검색</p>
<p>HandlerAdapter를 통한 핸들러 실행</p>
<p>ViewResolver를 통한 뷰 검색</p>
<p>ModelAndView를 이용한 뷰 실행</p>
<p>요청 처리 과정 종료</p>
<p>요청 처리 과정 시작<br>사용자가 HTTP 요청을 서버에 전송하면, 해당 요청은 DispatcherServlet에 의해 처리됩니다. DispatcherServlet은 스프링 컨테이너에 등록된 모든 빈을 검색하며, HandlerMapping, HandlerAdapter, ViewResolver 등의 빈을 찾아 사용합니다.</p>
<p>HandlerMapping을 통한 핸들러 검색<br>DispatcherServlet은 HandlerMapping 빈을 찾아 핸들러를 검색합니다. HandlerMapping은 요청 URI를 이용하여 적절한 핸들러를 검색하며, 해당 핸들러가 없을 경우 404 에러를 반환합니다.</p>
<p>HandlerAdapter를 통한 핸들러 실행<br>HandlerMapping을 통해 검색된 핸들러는 HandlerAdapter를 이용하여 실행됩니다. HandlerAdapter는 검색된 핸들러가 처리할 수 있는 형태로 요청을 변환하고, 핸들러가 처리한 결과를 ModelAndView 객체에 담아 반환합니다.</p>
<p>ViewResolver를 통한 뷰 검색<br>ModelAndView 객체는 DispatcherServlet에 반환됩니다. DispatcherServlet은 ViewResolver 빈을 이용하여 뷰를 검색합니다. ViewResolver는 검색된 뷰의 위치와 형식을 찾아 반환합니다.</p>
<p>ModelAndView를 이용한 뷰 실행<br>검색된 뷰는 DispatcherServlet에 의해 실행됩니다. ModelAndView 객체에 담겨있는 데이터를 이용하여 뷰가 생성되며, HTML, JSP, JSON 등의 형식으로 응답됩니다.</p>
<p>요청 처리 과정 종료<br>뷰가 실행된 후, DispatcherServlet은 요청 처리 과정을 종료합니다. 이때, 요청과 응답 객체는 Servlet Container에 반환됩니다.</p>
<p>스프링 MVC의 라이프사이클은 요청 처리에 필요한 여러 개의 빈들을 순서에 맞게 실행하며, 요청과 응답 객체를 생성 및 관리합니다. 이를 통해 사용자 요청에 대한 적절한 응답을 반환할 수 있습니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98/" class="post-title-link" itemprop="url">스프링부트 배치</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 10:08:44" itemprop="dateCreated datePublished" datetime="2023-04-13T10:08:44+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%B0%B0%EC%B9%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/스프링부트-배치/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>스프링 배치는 대량의 데이터를 처리하는 데 유용한 오픈소스 프레임워크이다. 이를 이용하여 데이터베이스나 파일 시스템과 같은 데이터 저장소에서 데이터를 추출하고 가공한 후, 다시 저장소에 저장하는 등의 작업을 수행할 수 있다. 이를 통해 대량의 데이터를 효율적으로 처리할 수 있으며, 이를 자동화하여 일괄처리를 가능하게 하여 개발자의 업무 효율성을 높일 수 있다.</p>
<p>스프링 배치의 장점은 다음과 같다.</p>
<ul>
<li>대량의 데이터를 처리하는데 최적화되어 있다.</li>
<li>배치 작업의 이력을 관리하며, 실패한 작업을 다시 수행할 수 있다.</li>
<li>스케줄링 기능을 지원하여 주기적인 작업을 자동화할 수 있다.</li>
<li>재사용성이 높은 컴포넌트 기반 아키텍처를 제공한다.</li>
</ul>
<p>따라서, 대량의 데이터를 처리하고자 할 때 스프링 배치를 사용하는 것이 유용하며, 스프링 프레임워크를 사용하는 경우에는 쉽게 연동하여 사용할 수 있다.</p>
<h2 id="사용-선택-기준"><a href="#사용-선택-기준" class="headerlink" title="사용 선택 기준"></a>사용 선택 기준</h2><p>스프링 배치를 사용하는 것이 적절한 경우는 대량의 데이터를 처리해야 할 때입니다. 이를 자동화하여 일괄 처리하고자 하는 경우에도 스프링 배치는 유용합니다. 예를 들어, 은행에서는 매일 수백만 건의 거래 데이터를 처리해야 하므로, 이를 스프링 배치를 이용하여 처리할 수 있습니다.</p>
<h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul>
<li>대량의 데이터를 처리하는 데 최적화되어 있습니다.</li>
<li>배치 작업의 이력을 관리할 수 있어, 실패한 작업을 다시 수행할 수 있습니다.</li>
<li>스케줄링 기능을 제공하여 주기적인 작업을 자동화할 수 있습니다.</li>
<li>재사용성이 높은 컴포넌트 기반 아키텍처를 제공합니다.</li>
</ul>
<h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><ul>
<li>배치 작업을 위한 코드를 작성하려면 일정한 학습 곡선이 필요합니다.</li>
<li>배치 작업을 디버깅하고 문제를 해결하는 데 시간이 걸릴 수 있습니다.</li>
</ul>
<h2 id="멱등성은-어떻게-유지하는가"><a href="#멱등성은-어떻게-유지하는가" class="headerlink" title="멱등성은 어떻게 유지하는가?"></a>멱등성은 어떻게 유지하는가?</h2><p>멱등성이란, 같은 작업을 여러 번 수행해도 결과가 변하지 않는 성질을 말합니다. 스프링 배치에서는 이러한 멱등성을 유지하기 위해 여러 가지 방법을 제공합니다. 예를 들어, 아래와 같은 방법으로 멱등성을 유지할 수 있습니다.</p>
<ul>
<li>BatchStatus 컬럼을 이용하여 이미 성공한 작업은 다시 수행하지 않도록 합니다.</li>
<li>JobInstance와 JobExecution의 ID를 이용하여 이미 실행한 작업을 식별하고 중복 실행을 방지합니다.</li>
</ul>
<h2 id="스프링-배치-메타데이터-테이블은-어떤-것이-있나"><a href="#스프링-배치-메타데이터-테이블은-어떤-것이-있나" class="headerlink" title="스프링 배치 메타데이터 테이블은 어떤 것이 있나?"></a>스프링 배치 메타데이터 테이블은 어떤 것이 있나?</h2><p>스프링 배치에서는 배치 작업의 메타데이터를 저장하기 위한 테이블을 제공합니다. 이 테이블은 JobRepository 인터페이스를 통해 접근할 수 있습니다. 스프링 배치가 제공하는 기본 메타데이터 테이블은 다음과 같습니다.</p>
<ul>
<li>BATCH_JOB_INSTANCE: JobInstance 정보를 저장합니다.</li>
<li>BATCH_JOB_EXECUTION: JobExecution 정보를 저장합니다.</li>
<li>BATCH_JOB_EXECUTION_CONTEXT: JobExecution의 ExecutionContext 정보를 저장합니다.</li>
<li>BATCH_STEP_EXECUTION: StepExecution 정보를 저장합니다.</li>
<li>BATCH_JOB_PARAMS: Job 파라미터 정보를 저장합니다.</li>
<li>BATCH_STEP_EXECUTION_CONTEXT: StepExecution의 ExecutionContext 정보를 저장합니다.</li>
</ul>
<h2 id="배치-실행-도중-실패시-처리-방법"><a href="#배치-실행-도중-실패시-처리-방법" class="headerlink" title="배치 실행 도중 실패시 처리 방법?"></a>배치 실행 도중 실패시 처리 방법?</h2><p>스프링 배치에서 배치 실행 도중 실패한 경우, 실패한 스텝을 재시도하거나 다음 스텝으로 진행하지 않고 중단하는 등의 처리 방법을 선택할 수 있습니다. 이러한 처리 방법을 설정하기 위해서는 Retry와 Skip 기능을 이용할 수 있습니다.</p>
<ul>
<li>Retry: 스텝이 실패한 경우 지정된 횟수만큼 재시도합니다. 예를 들어, ItemReader에서 데이터를 읽어올 때 DB 커넥션 오류 등으로 인해 실패한 경우, 일정 시간이 지난 후에 다시 시도합니다.</li>
<li>Skip: 스텝이 실패한 경우, 실패한 데이터를 스킵하고 다음 데이터로 넘어갑니다. 이를 이용하여, 예외가 발생해도 작업이 중단되지 않도록 할 수 있습니다.</li>
</ul>
<h2 id="스프링-배치-멀티스레드-파티션-방법과-차이점"><a href="#스프링-배치-멀티스레드-파티션-방법과-차이점" class="headerlink" title="스프링 배치 멀티스레드, 파티션 방법과 차이점"></a>스프링 배치 멀티스레드, 파티션 방법과 차이점</h2><p>스프링 배치에서 멀티스레드와 파티션 방법은 모두 대량의 데이터를 처리하는 데 사용됩니다. 멀티스레드는 스텝 내에서 다수의 스레드를 사용하여 처리 속도를 높이는 방법이고, 파티션 방법은 여러 개의 작은 작업 단위로 분할하여 병렬 처리하는 방법입니다. 두 방법의 차이점은 다음과 같습니다.</p>
<ul>
<li>멀티스레드: 스텝 내에서 스레드를 사용하여 처리합니다. 하나의 스텝을 여러 개의 스레드로 분할하여 처리할 수 있습니다. 처리 속도를 높일 수 있으나, 스레드 간의 동기화 문제나 데드락 등의 문제가 발생할 수 있습니다.</li>
<li>파티션: 대량의 데이터를 작은 단위로 나누어 여러 개의 스텝으로 분할하여 처리합니다. 각각의 스텝은 병렬로 처리됩니다. 데이터 분할이 복잡하고 처리 과정에서 추가적인 오버헤드가 발생할 수 있습니다.</li>
</ul>
<h2 id="스프링배치에서-트랜잭션-관리를-왜-청크-단위로-하는지"><a href="#스프링배치에서-트랜잭션-관리를-왜-청크-단위로-하는지" class="headerlink" title="스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지"></a>스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지</h2><p>스프링 배치에서 트랜잭션 관리는 청크 단위로 수행됩니다. 이는 대량의 데이터를 처리할 때 메모리 부족 현상을 방지하고, 롤백 시에도 데이터 일관성을 유지하기 위한 것입니다. 예를 들어, 10000건의 데이터를 처리하는데 트랜잭션 범위를 1건 단위로 처리하면, 10000번의 INSERT 작업마다 커밋을 수행해야 합니다. 이는 DB나 메모리 등에서 성능 저하를 일으킬 수 있으며, 롤백 시에도 일부 데이터만 롤백되어 데이터 일관성이 깨질 가능성이 있습니다. 하지만 청크 단위로 처리하면, 1000건 단위로 처리하면 10번의 INSERT 작업마다 커밋을 수행하므로 성능 저하 문제가 줄어들고, 롤백 시에도 청크 단위로 롤백되어 데이터 일관성이 유지됩니다.</p>
<h2 id="테스킷-vs-Reader-x2F-Writer-차이"><a href="#테스킷-vs-Reader-x2F-Writer-차이" class="headerlink" title="테스킷 vs Reader&#x2F;Writer 차이"></a>테스킷 vs Reader&#x2F;Writer 차이</h2><p>테스킷(Tasklet)과 Reader&#x2F;Writer는 스프링 배치에서 데이터 처리를 위해 사용되는 두 가지 방법입니다. 테스킷은 간단한 처리를 수행하고 스텝을 종료할 때 사용되는 반면, Reader&#x2F;Writer는 대량의 데이터 처리를 위해 사용됩니다.</p>
<ul>
<li>테스킷: 스텝 내에서 수행되는 단일 작업입니다. 스텝 시작 시 한 번만 실행되며, 간단한 데이터 처리를 수행합니다. 예를 들어, 파일을 이동하거나, 이메일을 발송하는 등의 작업을 수행할 수 있습니다.</li>
<li>Reader&#x2F;Writer: 대량의 데이터 처리를 위해 사용됩니다. Reader는 데이터를 읽어오고, Writer는 데이터를 저장합니다. 예를 들어, 데이터베이스에서 대량의 데이터를 읽어와서 파일로 저장하는 등의 작업을 수행할 수 있습니다.</li>
</ul>
<h2 id="배치-실행은-젠킨스-실행-및-스케쥴링-관점으로"><a href="#배치-실행은-젠킨스-실행-및-스케쥴링-관점으로" class="headerlink" title="배치 실행은? 젠킨스(실행 및 스케쥴링) 관점으로"></a>배치 실행은? 젠킨스(실행 및 스케쥴링) 관점으로</h2><p>젠킨스에서 스프링 배치를 실행하고 스케줄링하는 방법은 다음과 같습니다.</p>
<ol>
<li>젠킨스 홈페이지에 접속합니다.</li>
<li>젠킨스 대시보드에서 “새로운 Item 생성” 버튼을 클릭합니다.</li>
<li>“스프링 배치 프로젝트”를 선택합니다.</li>
<li>필요한 설정을 입력합니다. (프로젝트 이름, 저장소, 빌드 설정 등)</li>
<li>“빌드 유발” 탭에서 “정기적으로 빌드”를 선택하고, 스케줄링을 설정합니다.</li>
<li>“빌드” 탭에서 스프링 배치를 실행하는 명령어를 입력합니다. (예: java -jar batch.jar)</li>
</ol>
<h2 id="배치-보니터링-방법은-지연되는-배치-등-모니터링-및-후속-처리-관점으로"><a href="#배치-보니터링-방법은-지연되는-배치-등-모니터링-및-후속-처리-관점으로" class="headerlink" title="배치 보니터링 방법은? 지연되는 배치 등 모니터링 및 후속 처리 관점으로"></a>배치 보니터링 방법은? 지연되는 배치 등 모니터링 및 후속 처리 관점으로</h2><p>스프링 배치의 모니터링 및 후속 처리는 스프링 배치가 제공하는 JobExplorer를 이용하여 수행할 수 있습니다. JobExplorer는 배치 작업의 상태를 조회하고, 재시작 및 중지 등의 제어를 수행할 수 있습니다. JobExplorer를 이용하여 지연되는 배치 작업 등을 모니터링하고, 후속 처리를 수행할 수 있습니다. 예를 들어, 아래와 같은 방법으로 JobExplorer를 이용하여 배치 작업을 모니터링할 수 있습니다.</p>
<ol>
<li>JobExplorer를 이용하여 JobInstance와 JobExecution 정보를 조회합니다.</li>
<li>조회한 정보를 이용하여 JobExecution의 상태를 확인하고, 작업이 지연되었는지 확인합니다.</li>
<li>작업이 지연되었을 경우, 작업을 재시작하거나 중지하는 등의 후속 처리를 수행합니다.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/" class="post-title-link" itemprop="url">이진탐색트리</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 10:04:41" itemprop="dateCreated datePublished" datetime="2023-04-13T10:04:41+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/이진탐색트리/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>이진 탐색 트리(Binary Search Tree)는 이진 트리(Binary Tree)의 한 종류로서, 각 노드가 하나의 키(Key)를 저장하는 자료 구조입니다. 이진 탐색 트리는 다음과 같은 특성을 가지고 있습니다.</p>
<ul>
<li>루트 노드를 기준으로 왼쪽 서브트리의 키는 모두 루트 노드의 키보다 작습니다.</li>
<li>루트 노드를 기준으로 오른쪽 서브트리의 키는 모두 루트 노드의 키보다 큽니다.</li>
<li>왼쪽 서브트리와 오른쪽 서브트리도 모두 이진 탐색 트리여야 합니다.</li>
<li>중복된 키를 가지지 않습니다.</li>
<li>이진 탐색 트리에서는 탐색, 삽입, 삭제 연산을 O(log n)의 시간 복잡도로 수행할 수 있습니다. 이진 탐색 트리는 탐색이나 삽입, 삭제 연산을 할 때, 항상 트리의 루트 노드부터 시작하여 탐색하므로 탐색 범위를 빠르게 줄일 수 있습니다.</li>
</ul>
<p>이진 탐색 트리는 정렬된 데이터의 삽입&#x2F;삭제&#x2F;검색에 적합한 자료 구조입니다. 하지만 트리의 구조가 한쪽으로 치우칠 경우, 트리의 높이가 길어져 연산 속도가 떨어지는 문제가 있습니다. 이러한 문제를 해결하기 위해 AVL 트리, 레드-블랙 트리 등의 균형 이진 탐색 트리가 개발되었습니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/treeset-%EA%B3%BC-hashset-%EC%9D%98-%EC%B0%A8%EC%9D%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/treeset-%EA%B3%BC-hashset-%EC%9D%98-%EC%B0%A8%EC%9D%B4/" class="post-title-link" itemprop="url">treeset 과 hashset 의 차이</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 10:03:13" itemprop="dateCreated datePublished" datetime="2023-04-13T10:03:13+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/treeset-%EA%B3%BC-hashset-%EC%9D%98-%EC%B0%A8%EC%9D%B4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/treeset-과-hashset-의-차이/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>내부적으로 해시 테이블을 사용하여 데이터를 저장합니다.<br>데이터의 중복을 허용하지 않습니다.<br>데이터의 순서가 보장되지 않습니다.<br>삽입, 삭제, 검색 시 O(1)의 시간 복잡도를 갖습니다.<br>순서가 중요하지 않은 데이터의 집합에 적합합니다.</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>내부적으로 이진 검색 트리를 사용하여 데이터를 저장합니다.<br>데이터의 중복을 허용하지 않습니다.<br>데이터의 순서가 정렬된 상태로 저장되며, 이진 검색 트리를 사용하기 때문에 검색 속도가 빠릅니다.<br>삽입, 삭제, 검색 시 O(log n)의 시간 복잡도를 갖습니다.<br>순서가 중요하거나, 정렬된 데이터의 집합에 적합합니다.<br>따라서, HashSet은 데이터의 순서가 중요하지 않을 때 사용하고, TreeSet은 데이터의 순서가 중요하거나 정렬된 데이터의 집합에서 사용하는 것이 적합합니다. TreeSet은 검색 속도가 빠르지만, 데이터의 크기가 커질수록 검색 속도가 느려질 수 있습니다. HashSet은 검색 속도가 일정하며, 데이터의 크기가 커져도 검색 속도에 큰 변화가 없습니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80-2/" class="post-title-link" itemprop="url">List, Set, Map의 차이와 선택방법</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 09:58:20" itemprop="dateCreated datePublished" datetime="2023-04-13T09:58:20+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80-2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/자바-기술-면접-답변-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="종류-별-특징"><a href="#종류-별-특징" class="headerlink" title="종류 별 특징"></a>종류 별 특징</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List는 순서가 있는 데이터의 집합입니다. 데이터의 중복을 허용합니다. 대표적인 구현 클래스로는 ArrayList, LinkedList, Vector가 있습니다.</p>
<p>ArrayList: 내부적으로 배열을 사용하여 데이터를 저장합니다. 데이터 추가&#x2F;삭제 시 기존 데이터를 복사하거나 이동해야 하는 단점이 있습니다. 대용량 데이터의 경우 불리할 수 있습니다.<br>LinkedList: 데이터를 연결 리스트로 구현하여 저장합니다. 데이터 추가&#x2F;삭제 시 다른 데이터를 영향받지 않으며, 데이터의 위치를 이동시키는 것이 간단합니다.<br>Vector: ArrayList와 유사하지만, 멀티스레드 환경에서 동기화된 메서드를 제공합니다. 대부분의 경우 ArrayList를 대신하여 사용됩니다.</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set은 순서가 없는 데이터의 집합입니다. 데이터의 중복을 허용하지 않습니다. 대표적인 구현 클래스로는 HashSet, TreeSet이 있습니다.</p>
<p>HashSet: 내부적으로 HashMap을 사용하여 데이터를 저장합니다. 데이터의 중복을 허용하지 않으며, 순서가 없습니다. 검색 속도가 빠릅니다.<br>TreeSet: 데이터를 정렬하여 저장합니다. 데이터의 중복을 허용하지 않으며, 오름차순이나 내림차순으로 데이터를 정렬할 수 있습니다.</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map은 key-value 쌍으로 이루어진 데이터의 집합입니다. key는 중복될 수 없으며, value는 중복될 수 있습니다. 대표적인 구현 클래스로는 HashMap, TreeMap이 있습니다.</p>
<p>HashMap: 내부적으로 해시 테이블을 사용하여 key-value 쌍을 저장합니다. key의 중복을 허용하지 않으며, 순서가 없습니다. 검색 속도가 빠릅니다.<br>TreeMap: 데이터를 정렬하여 key-value 쌍을 저장합니다. key의 중복을 허용하지 않으며, 오름차순이나 내림차순으로 데이터를 정렬할 수 있습니다.</p>
<h2 id="종류-별-선택방법"><a href="#종류-별-선택방법" class="headerlink" title="종류 별 선택방법"></a>종류 별 선택방법</h2><h6 id="1-데이터의-종류와-크기에-따라-선택하기"><a href="#1-데이터의-종류와-크기에-따라-선택하기" class="headerlink" title="1. 데이터의 종류와 크기에 따라 선택하기"></a>1. 데이터의 종류와 크기에 따라 선택하기</h6><pre><code>데이터의 종류와 크기에 따라 적절한 컬렉션 클래스를 선택하는 것이 중요합니다. 예를 들어, 원소의 개수가 많은 경우에는 검색 속도가 빠른 HashSet이나 HashMap을 사용하는 것이 좋습니다.
</code></pre>
<h6 id="2-데이터의-추가-x2F-삭제-빈도에-따라-선택하기"><a href="#2-데이터의-추가-x2F-삭제-빈도에-따라-선택하기" class="headerlink" title="2. 데이터의 추가&#x2F;삭제 빈도에 따라 선택하기"></a>2. 데이터의 추가&#x2F;삭제 빈도에 따라 선택하기</h6><pre><code>데이터의 추가/삭제 빈도에 따라 LinkedList나 TreeSet을 선택할 수 있습니다. 데이터의 추가/삭제가 빈번하게 일어나는 경우, LinkedList는 다른 데이터를 영향받지 않아 데이터 처리 속도가 빠릅니다. TreeSet은 데이터의 추가/삭제가 적은 경우에 사용할 수 있으며, 데이터를 정렬하여 저장하기 때문에 검색 속도가 빠릅니다.
</code></pre>
<h6 id="3-데이터의-정렬-여부에-따라-선택하기"><a href="#3-데이터의-정렬-여부에-따라-선택하기" class="headerlink" title="3. 데이터의 정렬 여부에 따라 선택하기"></a>3. 데이터의 정렬 여부에 따라 선택하기</h6><pre><code>데이터의 정렬 여부에 따라 ArrayList나 LinkedList, TreeSet을 선택할 수 있습니다. 데이터가 정렬되어 있지 않은 경우에는 ArrayList나 LinkedList를 사용하는 것이 좋습니다. TreeSet은 데이터를 정렬하여 저장하기 때문에 정렬된 데이터를 사용할 때 효과적입니다.
</code></pre>
<h6 id="4-동기화-여부에-따라-선택하기"><a href="#4-동기화-여부에-따라-선택하기" class="headerlink" title="4. 동기화 여부에 따라 선택하기"></a>4. 동기화 여부에 따라 선택하기</h6><pre><code>멀티스레드 환경에서는 동기화된 컬렉션 클래스를 사용해야 합니다. 동기화된 컬렉션 클래스로는 Vector, Hashtable, synchronizedList, synchronizedSet, ConcurrentHashMap 등이 있습니다. 멀티스레드 환경에서는 동시성 문제가 발생할 수 있으므로, 이를 고려하여 적절한 컬렉션 클래스를 선택해야 합니다.
</code></pre>
<h6 id="5-데이터의-검색-빈도에-따라-선택하기"><a href="#5-데이터의-검색-빈도에-따라-선택하기" class="headerlink" title="5. 데이터의 검색 빈도에 따라 선택하기"></a>5. 데이터의 검색 빈도에 따라 선택하기</h6><pre><code>데이터의 검색 빈도에 따라 HashMap, TreeMap, LinkedHashMap 중 하나를 선택할 수 있습니다. 검색 속도가 빠른 HashMap은 데이터의 순서가 중요하지 않은 경우에 유용합니다. 순서가 중요한 경우에는 TreeMap이나 LinkedHashMap를 사용하는 것이 좋습니다.
</code></pre>
<h6 id="6-쓰레드-안전-여부에-따라-선택하기"><a href="#6-쓰레드-안전-여부에-따라-선택하기" class="headerlink" title="6. 쓰레드 안전 여부에 따라 선택하기"></a>6. 쓰레드 안전 여부에 따라 선택하기</h6><pre><code>쓰레드 안전 여부에 따라 ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet 등의 컬렉션 클래스를 선택할 수 있습니다. 이들은 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
</code></pre>
<h6 id="7-메모리-사용량과-성능에-따라-선택하기"><a href="#7-메모리-사용량과-성능에-따라-선택하기" class="headerlink" title="7. 메모리 사용량과 성능에 따라 선택하기"></a>7. 메모리 사용량과 성능에 따라 선택하기</h6><pre><code>메모리 사용량과 성능에 따라 ArrayList나 LinkedList, HashSet나 TreeSet, HashMap나 TreeMap 중 하나를 선택할 수 있습니다. 메모리 사용량이 적은 ArrayList나 HashSet을 사용하면 속도가 빨라질 수 있습니다. 대용량 데이터를 다룰 때는 LinkedList나 TreeSet, TreeMap을 사용하는 것이 좋습니다.
</code></pre>
<h6 id="8-컬렉션의-특징에-따라-선택하기"><a href="#8-컬렉션의-특징에-따라-선택하기" class="headerlink" title="8. 컬렉션의 특징에 따라 선택하기"></a>8. 컬렉션의 특징에 따라 선택하기</h6><pre><code>컬렉션의 특징에 따라 선택하는 것도 중요합니다. 예를 들어, ArrayList는 순차적인 데이터 처리에 유용하며, HashSet은 중복 데이터 처리에 유용합니다. 이러한 특징을 고려하여 적절한 컬렉션 클래스를 선택하는 것이 좋습니다.
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80/" class="post-title-link" itemprop="url">자바 기술 면접 답변 1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 09:51:29" itemprop="dateCreated datePublished" datetime="2023-04-13T09:51:29+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8B%B5%EB%B3%80/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/자바-기술-면접-답변/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-String은-왜-불변객체인가요"><a href="#1-String은-왜-불변객체인가요" class="headerlink" title="1. String은 왜 불변객체인가요?"></a>1. String은 왜 불변객체인가요?</h3><p>String은 불변객체(immutable object)입니다. 즉, 한번 생성된 String 객체는 내부의 값이 변경될 수 없습니다. 이는 String 객체의 내용이 변경되지 않도록 보장하기 위해서입니다. 만약 String 객체가 변경되면 다른 객체에서도 해당 값에 접근하는 것이 불안정해지기 때문입니다.</p>
<h3 id="2-접근제어자의-종류와-특징"><a href="#2-접근제어자의-종류와-특징" class="headerlink" title="2. 접근제어자의 종류와 특징?"></a>2. 접근제어자의 종류와 특징?</h3><p>자바에서 접근제어자(access modifier)는 클래스, 필드, 메서드 등의 멤버에 대한 접근 권한을 제어합니다. 다음은 접근제어자의 종류와 특징입니다.</p>
<p>public: 어떤 클래스에서도 접근 가능합니다.<br>protected: 같은 패키지에서는 접근 가능하고, 다른 패키지의 자식 클래스에서도 접근 가능합니다.<br>default(package-private): 같은 패키지에서만 접근 가능합니다.<br>private: 같은 클래스에서만 접근 가능합니다.</p>
<h3 id="3-OOP의-4가지-특징"><a href="#3-OOP의-4가지-특징" class="headerlink" title="3. OOP의 4가지 특징?"></a>3. OOP의 4가지 특징?</h3><p>OOP(Object-Oriented Programming)의 4가지 특징은 다음과 같습니다.</p>
<p>캡슐화(encapsulation): 객체의 상태와 행동을 하나의 단위로 묶고 외부에서의 접근을 제어합니다.<br>상속(inheritance): 상위 클래스의 속성과 메서드를 하위 클래스에서 재사용할 수 있도록 합니다.<br>다형성(polymorphism): 같은 타입 또는 같은 인터페이스를 구현하는 객체들이 동일한 메서드를 호출하여 다른 방식으로 동작할 수 있도록 합니다.<br>추상화(abstraction): 객체의 복잡한 구조와 동작을 간단한 모델로 단순화하여 표현합니다.</p>
<h3 id="4-캡슐화와-은닉화의-특징"><a href="#4-캡슐화와-은닉화의-특징" class="headerlink" title="4. 캡슐화와 은닉화의 특징?"></a>4. 캡슐화와 은닉화의 특징?</h3><p>캡슐화와 은닉화는 객체지향 프로그래밍에서 데이터 보호와 관련된 개념입니다.</p>
<p>캡슐화(encapsulation): 객체의 상태와 행동을 하나의 단위로 묶고, 외부에서의 접근을 제어합니다. 캡슐화를 통해 객체의 내부 구현과 상태를 보호하고, 객체 간의 결합도를 낮춰 유지보수와 확장성을 높일 수 있습니다.<br>은닉화(data hiding): 객체의 내부 구현을 외부에 노출하지 않는 것입니다. 객체의 내부 데이터를 외부에서 직접 접근하지 못하도록 하여 데이터 보호함으로써 객체의 무결성을 보장하고, 객체의 내부 구현을 변경해도 외부 인터페이스를 유지할 수 있습니다. 은닉화를 통해 객체의 내부 구현을 감추고, 외부에서는 객체의 인터페이스를 통해 상호작용할 수 있습니다.</p>
<h3 id="5-OOP의-5대-원칙"><a href="#5-OOP의-5대-원칙" class="headerlink" title="5. OOP의 5대 원칙?"></a>5. OOP의 5대 원칙?</h3><p>OOP의 5대 원칙(SOLID)은 다음과 같습니다.</p>
<p>SRP(Single Responsibility Principle): 클래스는 하나의 책임만 가져야 합니다.<br>OCP(Open-Closed Principle): 확장에는 열려있고, 변경에는 닫혀있어야 합니다.<br>LSP(Liskov Substitution Principle): 하위 클래스는 상위 클래스를 대체할 수 있어야 합니다.<br>ISP(Interface Segregation Principle): 인터페이스는 클라이언트에 필요한 메서드만 제공해야 합니다.<br>DIP(Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존하지 않아야 합니다.</p>
<h3 id="6-JVM-구조"><a href="#6-JVM-구조" class="headerlink" title="6. JVM 구조?"></a>6. JVM 구조?</h3><p>JVM(Java Virtual Machine)은 자바 프로그램을 실행하는 가상 머신입니다. JVM은 3가지 구성 요소로 이루어져 있습니다.</p>
<p>Class Loader: 컴파일된 자바 클래스 파일을 메모리에 로딩합니다.<br>Execution Engine: 로딩된 클래스 파일을 실행합니다.<br>Runtime Data Areas: JVM에서 메모리를 관리하는 영역으로, Method Area, Heap, Java Stack, Native Stack 등으로 구성됩니다.</p>
<h3 id="7-클래스-객체-인스턴스의-차이"><a href="#7-클래스-객체-인스턴스의-차이" class="headerlink" title="7. 클래스, 객체, 인스턴스의 차이?"></a>7. 클래스, 객체, 인스턴스의 차이?</h3><p>클래스는 객체를 만들기 위한 일종의 설계도이며, 객체는 클래스를 통해 생성된 실체입니다. 인스턴스는 객체가 메모리에 할당된 상태를 의미합니다.</p>
<h3 id="8-interface와-abstract-class의-차이"><a href="#8-interface와-abstract-class의-차이" class="headerlink" title="8. interface와 abstract class의 차이?"></a>8. interface와 abstract class의 차이?</h3><p>interface와 abstract class는 모두 추상화를 위한 개념입니다. 다음은 둘의 차이점입니다.</p>
<p>interface는 모든 메서드가 추상 메서드이며, 구현부를 가질 수 없습니다. 반면, abstract class는 추상 메서드와 구현된 메서드를 모두 포함할 수 있습니다.<br>interface는 다중 상속이 가능합니다. 반면, abstract class는 단일 상속만 가능합니다.<br>interface는 클래스에서 implements 키워드를 사용하여 구현합니다. 반면, abstract class는 extends 키워드를 사용하여 상속합니다.</p>
<h3 id="9-CheckedException과-UncheckedException의-차이"><a href="#9-CheckedException과-UncheckedException의-차이" class="headerlink" title="9. CheckedException과 UncheckedException의 차이?"></a>9. CheckedException과 UncheckedException의 차이?</h3><p>CheckedException은 예외 처리가 강제되는 예외입니다. 컴파일 시점에서 예외 처리를 확인하며, 예외를 처리하지 않으면 코드를 컴파일할 수 없습니다. 대표적인 예로는 IOException, ClassNotFoundException 등이 있습니다. 반면, UncheckedException은 예외 처리가 강제되지 않는 예외입니다. 컴파일 시점에서 확인하지 않으며, 런타임 시점에서 예외가 발생합니다. 대표적인 예로는 NullPointerException, ArrayIndexOutOfBoundsException 등이 있습니다.</p>
<h3 id="10-Call-by-Reference와-Call-by-Value의-차이"><a href="#10-Call-by-Reference와-Call-by-Value의-차이" class="headerlink" title="10. Call by Reference와 Call by Value의 차이?"></a>10. Call by Reference와 Call by Value의 차이?</h3><p>Call by Value는 메서드 호출 시 인자로 전달된 값의 복사본을 생성하여 사용합니다. 메서드 내부에서 복사본을 변경해도 원본 값에는 영향을 주지 않습니다. 반면, Call by Reference는 메서드 호출 시 인자로 전달된 값의 메모리 주소를 참조합니다. 따라서 메서드 내부에서 값이 변경되면 원본 값에도 영향을 주게 됩니다.</p>
<h3 id="11-오버로딩과-오버라이딩의-차이"><a href="#11-오버로딩과-오버라이딩의-차이" class="headerlink" title="11. 오버로딩과 오버라이딩의 차이?"></a>11. 오버로딩과 오버라이딩의 차이?</h3><p>오버로딩(Overloading)은 같은 이름의 메서드를 여러 개 정의하는 것을 말합니다. 매개변수의 개수, 타입, 순서가 다르면 오버로딩이 가능합니다. 반면, 오버라이딩(Overriding)은 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하는 것을 말합니다. 메서드의 시그니처(이름, 매개변수 타입, 반환 타입)가 동일해야 합니다.</p>
<h3 id="12-스레드세이프-Thread-Safe"><a href="#12-스레드세이프-Thread-Safe" class="headerlink" title="12. 스레드세이프(Thread-Safe)"></a>12. 스레드세이프(Thread-Safe)</h3><p>스레드세이프란 여러 스레드가 동시에 접근해도 안전하게 사용할 수 있는 코드를 말합니다. 스레드세이프한 코드는 멀티스레드 환경에서 동시성 문제를 방지하고, 데이터의 일관성을 유지합니다.</p>
<h3 id="13-Garbage-Collector는-어떻게-동작하는지"><a href="#13-Garbage-Collector는-어떻게-동작하는지" class="headerlink" title="13. Garbage Collector는 어떻게 동작하는지?"></a>13. Garbage Collector는 어떻게 동작하는지?</h3><p>Garbage Collector는 JVM에서 사용되지 않는 객체를 자동으로 해제하는 기능입니다. Garbage Collector는 객체가 생성된 시점, 참조되지 않는 시점 등을 추적하여 사용되지 않는 객체를 메모리에서 해제합니다.</p>
<h3 id="14-제네릭을-왜-쓰는지"><a href="#14-제네릭을-왜-쓰는지" class="headerlink" title="14. 제네릭을 왜 쓰는지?"></a>14. 제네릭을 왜 쓰는지?</h3><p>제네릭은 자바에서 컬렉션의 타입 안정성을 보장하기 위해 사용됩니다. 제네릭을 사용하면 컬렉션에 저장된 요소의 타입을 컴파일 시점에 확인할 수 있으며, 타입안정성이 높아집니다. 또한 제네릭은 코드의 재사용성을 높여줍니다. 제네릭을 사용하면 같은 코드를 여러 타입에서 사용할 수 있기 때문입니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jspgmp.github.io/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/exploreHA/images/avatar.gif">
      <meta itemprop="name" content="북극여우">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="블로그제목">
      <meta itemprop="description" content="설명">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 블로그제목">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D-1/" class="post-title-link" itemprop="url">자바 기술면접 질문목록</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-13 09:29:41" itemprop="dateCreated datePublished" datetime="2023-04-13T09:29:41+09:00">2023-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/exploreHA/2023/04/13/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/04/13/자바-기술면접-질문목록-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="자바"><a href="#자바" class="headerlink" title="자바"></a>자바</h2><ol>
<li>String 은 왜 불변객체인가 ? </li>
<li>접근제어자의 종류와 특징 ? </li>
<li>OOP 의 4가지 특징 ? </li>
<li>캡슐화와 은닉화의 특징 ? </li>
<li>OOP의 5대 원칙 ? </li>
<li>JVM 구조</li>
<li>클래스, 객체, 인스턴스의 차이</li>
<li>interface와 abstract class의 차이</li>
<li>checkedException 과 uncheckedException의 차이</li>
<li>Call by Reference 와 Call by value 의 차이</li>
<li>오버로딩과 오버라이딩의 차이</li>
<li>쓰레드세이프</li>
<li>Garbage Collector는 어떻게 동작하는지 ? </li>
<li>제네릭을 왜 쓰는지 ? </li>
<li>list, set, map 의 차이</li>
<li>이진탐색트리란 ? </li>
<li>treeset 과 hashset 의 차이</li>
</ol>
<h2 id="자바-배치"><a href="#자바-배치" class="headerlink" title="자바 배치"></a>자바 배치</h2><ol>
<li>왜 스프링 배치를 사용하는가?</li>
</ol>
<ul>
<li>해당 기술 사용 선택 기준사한, 장단점</li>
</ul>
<ol start="2">
<li>멱등성은 어떻게 유지하는가</li>
<li>스프링 배치 메타데이터 테이블은 어떤 것이 있나</li>
<li>배치 실행 도중 실패시 처리 방법</li>
</ol>
<ul>
<li>Skip, Retry 개념 및 사용 경험</li>
</ul>
<ol start="5">
<li>스프링 배치 멀티스레드, 파티션 방법과 차이점 </li>
<li>스프링배치에서 트랜잭션 관리를 왜 청크 단위로 하는지 </li>
<li>테스킷 ve Reader&#x2F;Write 차이</li>
<li>커서 vs 페이징 차이, 사용 클래스 </li>
<li>배치 실행은?</li>
</ol>
<ul>
<li>젠킨스(실행 및 스케쥴링)</li>
</ul>
<ol start="10">
<li>배치 보니터링 방법</li>
</ol>
<ul>
<li>지연되는 배치 등 모니처링 및 후속 처리</li>
</ul>
<h2 id="자바-스프링부트"><a href="#자바-스프링부트" class="headerlink" title="자바 스프링부트"></a>자바 스프링부트</h2><ol>
<li>필터와 인터셉터의 차이</li>
<li>스프링부트는 왜 생긴것인가? </li>
<li>스프링 DI 란 무엇인가 ? </li>
<li>스프링 IOC 란 무엇인가 ? </li>
<li>스프링 ORM 이란 무엇인가 ?</li>
<li>Hibernate 란 무엇인가 ? </li>
<li>객체 주입방식 종류와 특징, 차이점</li>
<li>스프링 MVC life cycle 구조</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/exploreHA/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/exploreHA/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.3.0/mermaid.min.js","integrity":"sha256-QdTG1YTLLTwD3b95jLqFxpQX9uYuJMNAtVZgwKX4oYU="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/third-party/tags/mermaid.min.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/third-party/math/mathjax.min.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"next-theme","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.14.1/third-party/comments/disqus.min.js"></script>

</body>
</html>
